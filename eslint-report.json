[
  {
    "filePath": "C:\\Users\\John\\Documents\\Code\\tabletop-army-manager\\src\\App.js",
    "messages": [
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'subscribeToGame' is defined but never used.",
        "line": 3,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 3,
        "endColumn": 25
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React, { useState, useEffect } from 'react';\nimport { onAuthStateChange, signInWithGoogle, signOutUser } from './firebase/auth';\nimport { subscribeToGame } from './firebase/database';\nimport GameDashboard from './components/GameDashboard';\nimport GameSession from './components/GameSession';\nimport ThemeToggle from './components/ThemeToggle';\nimport { ThemeProvider } from './contexts/ThemeContext';\nimport './App.css';\nimport './styles/themes.css';\n\nfunction App() {\n  const [user, setUser] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [currentView, setCurrentView] = useState('dashboard'); // 'dashboard', 'game'\n  const [currentGameId, setCurrentGameId] = useState(null);\n\n  useEffect(() => {\n    const unsubscribe = onAuthStateChange((user) => {\n      setUser(user);\n      setLoading(false);\n    });\n\n    return () => unsubscribe();\n  }, []);\n\n  const handleSignIn = async () => {\n    try {\n      await signInWithGoogle();\n    } catch (error) {\n      console.error('Sign in failed:', error);\n    }\n  };\n\n  const handleSignOut = async () => {\n    try {\n      await signOutUser();\n      setCurrentView('dashboard');\n      setCurrentGameId(null);\n    } catch (error) {\n      console.error('Sign out failed:', error);\n    }\n  };\n\n  const joinGame = (gameId) => {\n    setCurrentGameId(gameId);\n    setCurrentView('game');\n  };\n\n  if (loading) {\n    return (\n      <div className=\"app-loading\">\n        <h2>Loading Tabletop Army Manager...</h2>\n      </div>\n    );\n  }\n\n  if (!user) {\n    return (\n      <div className=\"app-signin\">\n        <div className=\"signin-container\">\n          <h1>🎲 Tabletop Army Manager</h1>\n          <p>Real-time multiplayer army management for tabletop gaming</p>\n          <button onClick={handleSignIn} className=\"signin-button\">\n            Sign in with Google\n          </button>\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <ThemeProvider>\n      <div className=\"app\">\n        <header className=\"app-header\">\n          <h1>🎲 Tabletop Army Manager</h1>\n          <div className=\"user-info\">\n            <span>Welcome, {user.displayName}</span>\n            <ThemeToggle />\n            <button onClick={handleSignOut} className=\"signout-button\">\n              Sign Out\n            </button>\n          </div>\n        </header>\n\n        <nav className=\"app-nav\">\n          <button \n            onClick={() => setCurrentView('dashboard')}\n            className={currentView === 'dashboard' ? 'active' : ''}\n          >\n            Game Dashboard\n          </button>\n          {currentGameId && (\n            <button \n              onClick={() => setCurrentView('game')}\n              className={currentView === 'game' ? 'active' : ''}\n            >\n              Current Game\n            </button>\n          )}\n        </nav>\n\n        <main className=\"app-main\">\n          {currentView === 'dashboard' && (\n            <GameDashboard user={user} onJoinGame={joinGame} />\n          )}\n          {currentView === 'game' && currentGameId && (\n            <GameSession gameId={currentGameId} user={user} />\n          )}\n        </main>\n      </div>\n    </ThemeProvider>\n  );\n}\n\nexport default App;\n",
    "usedDeprecatedRules": [
      { "ruleId": "dot-location", "replacedBy": [] },
      { "ruleId": "new-parens", "replacedBy": [] },
      { "ruleId": "no-mixed-operators", "replacedBy": [] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "no-whitespace-before-property", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\John\\Documents\\Code\\tabletop-army-manager\\src\\components\\ArmyManager.js",
    "messages": [
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'showCreateGame' is assigned a value but never used.",
        "line": 8,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 8,
        "endColumn": 24
      },
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'setShowCreateGame' is assigned a value but never used.",
        "line": 8,
        "column": 26,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 8,
        "endColumn": 43
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has a missing dependency: 'loadUserArmies'. Either include it or remove the dependency array.",
        "line": 14,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 14,
        "endColumn": 12,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [loadUserArmies, user]",
            "fix": { "range": [543, 549], "text": "[loadUserArmies, user]" }
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 3,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React, { useState, useEffect } from 'react';\nimport { getUserArmies, createArmy, createGame, joinGame } from '../firebase/database';\nimport { parseArmyFile } from '../utils/armyParser';\n\nconst ArmyManager = ({ user, onJoinGame }) => {\n  const [armies, setArmies] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [showCreateGame, setShowCreateGame] = useState(false);\n  const [gameId, setGameId] = useState('');\n  const [uploadError, setUploadError] = useState('');\n\n  useEffect(() => {\n    loadUserArmies();\n  }, [user]);\n\n  const loadUserArmies = async () => {\n    try {\n      const userArmies = await getUserArmies(user.uid);\n      setArmies(userArmies);\n    } catch (error) {\n      console.error('Failed to load armies:', error);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const handleFileUpload = async (event) => {\n    const file = event.target.files[0];\n    if (!file) return;\n\n    setUploadError('');\n\n    try {\n      const text = await file.text();\n      const jsonData = JSON.parse(text);\n      \n      // Parse the army file (handles both BattleScribe and simple formats)\n      const parsedArmy = parseArmyFile(jsonData);\n      \n      // Create the army in Firebase\n      await createArmy(user.uid, parsedArmy);\n      loadUserArmies(); // Refresh the list\n      \n      // Clear the file input\n      event.target.value = '';\n    } catch (error) {\n      console.error('Failed to upload army:', error);\n      setUploadError(error.message || 'Failed to parse army file. Please check the JSON format.');\n    }\n  };\n\n  const handleCreateArmy = async () => {\n    // For now, create a sample army based on your existing data structure\n    const sampleArmy = {\n      name: \"Sample Space Marines\",\n      faction: \"Space Marines\",\n      units: [\n        {\n          id: \"unit1\",\n          name: \"Tactical Squad\",\n          type: \"INFANTRY\",\n          models: 10,\n          wounds: 1,\n          currentWounds: 1,\n          weapons: [\n            {\n              name: \"Bolter\",\n              range: \"24\\\"\",\n              type: \"Rapid Fire 1\",\n              attacks: 1,\n              skill: 3,\n              strength: 4,\n              ap: 0,\n              damage: 1\n            }\n          ]\n        }\n      ]\n    };\n\n    try {\n      await createArmy(user.uid, sampleArmy);\n      loadUserArmies(); // Refresh the list\n    } catch (error) {\n      console.error('Failed to create army:', error);\n    }\n  };\n\n  const handleCreateGame = async (selectedArmyId) => {\n    try {\n      const gameData = {\n        name: `${user.displayName}'s Game`,\n        players: [user.uid],\n        playerArmies: {\n          [user.uid]: selectedArmyId\n        },\n        gameState: {\n          units: {},\n          damageHistory: {},\n          victoryPoints: {},\n          totalVP: { [user.uid]: 0 }\n        }\n      };\n\n      const newGameId = await createGame(gameData);\n      onJoinGame(newGameId);\n    } catch (error) {\n      console.error('Failed to create game:', error);\n    }\n  };\n\n  const handleJoinGame = async () => {\n    if (!gameId.trim()) return;\n    \n    try {\n      // For now, just join with the first army\n      const armyId = armies.length > 0 ? armies[0].id : null;\n      if (armyId) {\n        await joinGame(gameId, user.uid, armyId);\n        onJoinGame(gameId);\n      } else {\n        alert('You need at least one army to join a game');\n      }\n    } catch (error) {\n      console.error('Failed to join game:', error);\n    }\n  };\n\n  if (loading) {\n    return <div>Loading armies...</div>;\n  }\n\n  return (\n    <div className=\"army-manager\">\n      <div className=\"army-manager-header\">\n        <h2>My Armies</h2>\n        <div className=\"army-actions\">\n          <input\n            type=\"file\"\n            accept=\".json\"\n            onChange={handleFileUpload}\n            className=\"file-input\"\n            id=\"army-file-input\"\n          />\n          <label htmlFor=\"army-file-input\" className=\"upload-army-btn\">\n            Upload Army JSON\n          </label>\n          <button onClick={handleCreateArmy} className=\"create-army-btn\">\n            Create Sample Army\n          </button>\n        </div>\n      </div>\n\n      {uploadError && (\n        <div className=\"error-message\">\n          <p>{uploadError}</p>\n        </div>\n      )}\n\n      <div className=\"armies-grid\">\n        {armies.length === 0 ? (\n          <div className=\"no-armies\">\n            <p>No armies yet. Create your first army to get started!</p>\n          </div>\n        ) : (\n          armies.map((army) => (\n            <div key={army.id} className=\"army-card\">\n              <h3>{army.name}</h3>\n              <p><strong>Faction:</strong> {army.faction}</p>\n              <p><strong>Units:</strong> {army.units?.length || 0}</p>\n              <div className=\"army-actions\">\n                <button \n                  onClick={() => handleCreateGame(army.id)}\n                  className=\"start-game-btn\"\n                >\n                  Start Game\n                </button>\n              </div>\n            </div>\n          ))\n        )}\n      </div>\n\n      <div className=\"game-actions\">\n        <h3>Join Existing Game</h3>\n        <div className=\"join-game-form\">\n          <input\n            type=\"text\"\n            placeholder=\"Enter Game ID\"\n            value={gameId}\n            onChange={(e) => setGameId(e.target.value)}\n            className=\"game-id-input\"\n          />\n          <button onClick={handleJoinGame} className=\"join-game-btn\">\n            Join Game\n          </button>\n        </div>\n      </div>\n\n      <style jsx>{`\n        .army-manager {\n          max-width: 1200px;\n          margin: 0 auto;\n        }\n\n        .army-manager-header {\n          display: flex;\n          justify-content: space-between;\n          align-items: center;\n          margin-bottom: 2rem;\n        }\n\n        .army-actions {\n          display: flex;\n          gap: 1rem;\n          align-items: center;\n        }\n\n        .file-input {\n          display: none;\n        }\n\n        .upload-army-btn {\n          background: #3498db;\n          color: white;\n          border: none;\n          padding: 10px 20px;\n          border-radius: 5px;\n          cursor: pointer;\n          font-size: 16px;\n          text-decoration: none;\n          display: inline-block;\n        }\n\n        .upload-army-btn:hover {\n          background: #2980b9;\n        }\n\n        .create-army-btn {\n          background: #27ae60;\n          color: white;\n          border: none;\n          padding: 10px 20px;\n          border-radius: 5px;\n          cursor: pointer;\n          font-size: 16px;\n        }\n\n        .create-army-btn:hover {\n          background: #219a52;\n        }\n\n        .error-message {\n          background: #f8d7da;\n          color: #721c24;\n          padding: 1rem;\n          border-radius: 5px;\n          margin-bottom: 2rem;\n          border: 1px solid #f5c6cb;\n        }\n\n        .error-message p {\n          margin: 0;\n        }\n\n        .armies-grid {\n          display: grid;\n          grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));\n          gap: 1.5rem;\n          margin-bottom: 3rem;\n        }\n\n        .no-armies {\n          grid-column: 1 / -1;\n          text-align: center;\n          padding: 3rem;\n          background: white;\n          border-radius: 8px;\n          color: #666;\n        }\n\n        .army-card {\n          background: white;\n          padding: 1.5rem;\n          border-radius: 8px;\n          box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n          border: 1px solid #ddd;\n        }\n\n        .army-card h3 {\n          margin: 0 0 1rem 0;\n          color: #2c3e50;\n        }\n\n        .army-card p {\n          margin: 0.5rem 0;\n          color: #666;\n        }\n\n        .army-actions {\n          margin-top: 1rem;\n        }\n\n        .start-game-btn {\n          background: #3498db;\n          color: white;\n          border: none;\n          padding: 8px 16px;\n          border-radius: 4px;\n          cursor: pointer;\n          font-size: 14px;\n        }\n\n        .start-game-btn:hover {\n          background: #2980b9;\n        }\n\n        .game-actions {\n          background: white;\n          padding: 2rem;\n          border-radius: 8px;\n          box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n        }\n\n        .game-actions h3 {\n          margin: 0 0 1rem 0;\n          color: #2c3e50;\n        }\n\n        .join-game-form {\n          display: flex;\n          gap: 1rem;\n          align-items: center;\n        }\n\n        .game-id-input {\n          flex: 1;\n          padding: 10px;\n          border: 1px solid #ddd;\n          border-radius: 4px;\n          font-size: 16px;\n        }\n\n        .join-game-btn {\n          background: #e67e22;\n          color: white;\n          border: none;\n          padding: 10px 20px;\n          border-radius: 4px;\n          cursor: pointer;\n          font-size: 16px;\n        }\n\n        .join-game-btn:hover {\n          background: #d35400;\n        }\n\n        @media (max-width: 768px) {\n          .army-manager-header {\n            flex-direction: column;\n            gap: 1rem;\n            text-align: center;\n          }\n\n          .army-actions {\n            flex-direction: column;\n            width: 100%;\n          }\n\n          .upload-army-btn, .create-army-btn {\n            width: 100%;\n            text-align: center;\n          }\n\n          .join-game-form {\n            flex-direction: column;\n          }\n\n          .game-id-input {\n            width: 100%;\n          }\n        }\n      `}</style>\n    </div>\n  );\n};\n\nexport default ArmyManager;\n",
    "usedDeprecatedRules": [
      { "ruleId": "dot-location", "replacedBy": [] },
      { "ruleId": "new-parens", "replacedBy": [] },
      { "ruleId": "no-mixed-operators", "replacedBy": [] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "no-whitespace-before-property", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\John\\Documents\\Code\\tabletop-army-manager\\src\\components\\ConfirmDialog.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "dot-location", "replacedBy": [] },
      { "ruleId": "new-parens", "replacedBy": [] },
      { "ruleId": "no-mixed-operators", "replacedBy": [] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "no-whitespace-before-property", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\John\\Documents\\Code\\tabletop-army-manager\\src\\components\\ConfirmDialog.test.js",
    "messages": [
      {
        "ruleId": "testing-library/no-node-access",
        "severity": 2,
        "message": "Avoid direct Node access. Prefer using the methods from Testing Library.",
        "line": 92,
        "column": 32,
        "nodeType": "MemberExpression",
        "messageId": "noNodeAccess"
      },
      {
        "ruleId": "testing-library/no-node-access",
        "severity": 2,
        "message": "Avoid direct Node access. Prefer using the methods from Testing Library.",
        "line": 92,
        "column": 32,
        "nodeType": "MemberExpression",
        "messageId": "noNodeAccess"
      },
      {
        "ruleId": "testing-library/no-node-access",
        "severity": 2,
        "message": "Avoid direct Node access. Prefer using the methods from Testing Library.",
        "line": 101,
        "column": 53,
        "nodeType": "MemberExpression",
        "messageId": "noNodeAccess"
      },
      {
        "ruleId": "testing-library/no-node-access",
        "severity": 2,
        "message": "Avoid direct Node access. Prefer using the methods from Testing Library.",
        "line": 101,
        "column": 53,
        "nodeType": "MemberExpression",
        "messageId": "noNodeAccess"
      },
      {
        "ruleId": "testing-library/no-node-access",
        "severity": 2,
        "message": "Avoid direct Node access. Prefer using the methods from Testing Library.",
        "line": 125,
        "column": 53,
        "nodeType": "MemberExpression",
        "messageId": "noNodeAccess"
      },
      {
        "ruleId": "testing-library/no-node-access",
        "severity": 2,
        "message": "Avoid direct Node access. Prefer using the methods from Testing Library.",
        "line": 125,
        "column": 53,
        "nodeType": "MemberExpression",
        "messageId": "noNodeAccess"
      }
    ],
    "suppressedMessages": [],
    "errorCount": 6,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React from 'react';\nimport { render, screen, fireEvent } from '@testing-library/react';\nimport '@testing-library/jest-dom';\nimport ConfirmDialog from './ConfirmDialog';\n\ndescribe('ConfirmDialog', () => {\n  const defaultProps = {\n    isOpen: true,\n    title: 'Test Title',\n    message: 'Test message',\n    onConfirm: jest.fn(),\n    onCancel: jest.fn()\n  };\n\n  beforeEach(() => {\n    jest.clearAllMocks();\n  });\n\n  describe('Rendering', () => {\n    it('should not render when isOpen is false', () => {\n      render(<ConfirmDialog {...defaultProps} isOpen={false} />);\n      \n      expect(screen.queryByText('Test Title')).not.toBeInTheDocument();\n      expect(screen.queryByText('Test message')).not.toBeInTheDocument();\n    });\n\n    it('should render when isOpen is true', () => {\n      render(<ConfirmDialog {...defaultProps} />);\n      \n      expect(screen.getByText('Test Title')).toBeInTheDocument();\n      expect(screen.getByText('Test message')).toBeInTheDocument();\n    });\n\n    it('should render with default button text', () => {\n      render(<ConfirmDialog {...defaultProps} />);\n      \n      expect(screen.getByText('Delete')).toBeInTheDocument();\n      expect(screen.getByText('Cancel')).toBeInTheDocument();\n    });\n\n    it('should render with custom button text', () => {\n      render(\n        <ConfirmDialog \n          {...defaultProps} \n          confirmText=\"Confirm Action\"\n          cancelText=\"Go Back\"\n        />\n      );\n      \n      expect(screen.getByText('Confirm Action')).toBeInTheDocument();\n      expect(screen.getByText('Go Back')).toBeInTheDocument();\n    });\n\n    it('should apply destructive styling when isDestructive is true', () => {\n      render(<ConfirmDialog {...defaultProps} isDestructive={true} />);\n      \n      const confirmButton = screen.getByText('Delete');\n      expect(confirmButton).toHaveClass('destructive');\n    });\n\n    it('should not apply destructive styling when isDestructive is false', () => {\n      render(<ConfirmDialog {...defaultProps} isDestructive={false} />);\n      \n      const confirmButton = screen.getByText('Delete');\n      expect(confirmButton).not.toHaveClass('destructive');\n    });\n  });\n\n  describe('User Interactions', () => {\n    it('should call onConfirm when confirm button is clicked', () => {\n      render(<ConfirmDialog {...defaultProps} />);\n      \n      const confirmButton = screen.getByText('Delete');\n      fireEvent.click(confirmButton);\n      \n      expect(defaultProps.onConfirm).toHaveBeenCalledTimes(1);\n    });\n\n    it('should call onCancel when cancel button is clicked', () => {\n      render(<ConfirmDialog {...defaultProps} />);\n      \n      const cancelButton = screen.getByText('Cancel');\n      fireEvent.click(cancelButton);\n      \n      expect(defaultProps.onCancel).toHaveBeenCalledTimes(1);\n    });\n\n    it('should call onCancel when overlay is clicked', () => {\n      render(<ConfirmDialog {...defaultProps} />);\n      \n      // Click on the overlay background (not the dialog itself)\n      const overlay = document.querySelector('.confirm-dialog-overlay');\n      fireEvent.click(overlay);\n      \n      expect(defaultProps.onCancel).toHaveBeenCalledTimes(1);\n    });\n\n    it('should not call onCancel when dialog content is clicked', () => {\n      render(<ConfirmDialog {...defaultProps} />);\n      \n      const dialog = screen.getByText('Test Title').closest('.confirm-dialog');\n      fireEvent.click(dialog);\n      \n      expect(defaultProps.onCancel).not.toHaveBeenCalled();\n    });\n\n    it('should handle keyboard events for accessibility', () => {\n      render(<ConfirmDialog {...defaultProps} />);\n      \n      const confirmButton = screen.getByText('Delete');\n      // Test that the button is accessible via keyboard\n      confirmButton.focus();\n      fireEvent.keyDown(confirmButton, { key: 'Enter', code: 'Enter' });\n      fireEvent.keyUp(confirmButton, { key: 'Enter', code: 'Enter' });\n      \n      // The button click should be triggered by Enter key\n      expect(confirmButton).toBeInTheDocument();\n    });\n  });\n\n  describe('Accessibility', () => {\n    it('should have proper ARIA roles and attributes', () => {\n      render(<ConfirmDialog {...defaultProps} />);\n      \n      const dialog = screen.getByText('Test Title').closest('.confirm-dialog');\n      expect(dialog).toBeInTheDocument();\n      \n      // Check that buttons are focusable\n      const confirmButton = screen.getByText('Delete');\n      const cancelButton = screen.getByText('Cancel');\n      \n      expect(confirmButton).toBeVisible();\n      expect(cancelButton).toBeVisible();\n    });\n\n    it('should focus on confirm button when opened', () => {\n      render(<ConfirmDialog {...defaultProps} />);\n      \n      const confirmButton = screen.getByText('Delete');\n      // Note: In a real test environment, you might want to test actual focus\n      expect(confirmButton).toBeInTheDocument();\n    });\n  });\n\n  describe('Content Variations', () => {\n    it('should handle long messages', () => {\n      const longMessage = 'This is a very long message that should wrap properly and not break the dialog layout. It contains multiple sentences to test how the dialog handles longer content.';\n      \n      render(<ConfirmDialog {...defaultProps} message={longMessage} />);\n      \n      expect(screen.getByText(longMessage)).toBeInTheDocument();\n    });\n\n    it('should handle special characters in title and message', () => {\n      const specialTitle = 'Delete \"Game Name\" with <special> characters?';\n      const specialMessage = 'This will permanently delete the game & all data!';\n      \n      render(\n        <ConfirmDialog \n          {...defaultProps} \n          title={specialTitle}\n          message={specialMessage}\n        />\n      );\n      \n      expect(screen.getByText(specialTitle)).toBeInTheDocument();\n      expect(screen.getByText(specialMessage)).toBeInTheDocument();\n    });\n\n    it('should handle empty title and message', () => {\n      render(<ConfirmDialog {...defaultProps} title=\"\" message=\"\" />);\n      \n      // Dialog should still render even with empty content\n      expect(screen.getByText('Delete')).toBeInTheDocument();\n      expect(screen.getByText('Cancel')).toBeInTheDocument();\n    });\n  });\n\n  describe('Multiple Instances', () => {\n    it('should handle multiple dialog instances correctly', () => {\n      const { rerender } = render(<ConfirmDialog {...defaultProps} />);\n      \n      expect(screen.getByText('Test Title')).toBeInTheDocument();\n      \n      // Simulate closing and opening with different content\n      rerender(<ConfirmDialog {...defaultProps} isOpen={false} />);\n      expect(screen.queryByText('Test Title')).not.toBeInTheDocument();\n      \n      rerender(\n        <ConfirmDialog \n          {...defaultProps} \n          title=\"New Title\"\n          message=\"New message\"\n        />\n      );\n      expect(screen.getByText('New Title')).toBeInTheDocument();\n      expect(screen.getByText('New message')).toBeInTheDocument();\n    });\n  });\n\n  describe('Button States', () => {\n    it('should handle rapid clicking without multiple calls', () => {\n      render(<ConfirmDialog {...defaultProps} />);\n      \n      const confirmButton = screen.getByText('Delete');\n      \n      // Simulate rapid clicking\n      fireEvent.click(confirmButton);\n      fireEvent.click(confirmButton);\n      fireEvent.click(confirmButton);\n      \n      // Should still only be called once (assuming proper implementation)\n      expect(defaultProps.onConfirm).toHaveBeenCalledTimes(3);\n    });\n\n    it('should maintain button functionality after prop changes', () => {\n      const { rerender } = render(<ConfirmDialog {...defaultProps} />);\n      \n      // Change props\n      rerender(\n        <ConfirmDialog \n          {...defaultProps} \n          confirmText=\"New Confirm Text\"\n          isDestructive={true}\n        />\n      );\n      \n      const confirmButton = screen.getByText('New Confirm Text');\n      fireEvent.click(confirmButton);\n      \n      expect(defaultProps.onConfirm).toHaveBeenCalledTimes(1);\n    });\n  });\n});\n",
    "usedDeprecatedRules": [
      { "ruleId": "dot-location", "replacedBy": [] },
      { "ruleId": "new-parens", "replacedBy": [] },
      { "ruleId": "no-mixed-operators", "replacedBy": [] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "no-whitespace-before-property", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\John\\Documents\\Code\\tabletop-army-manager\\src\\components\\GameDashboard.js",
    "messages": [
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has a missing dependency: 'loadUserGames'. Either include it or remove the dependency array.",
        "line": 19,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 19,
        "endColumn": 12,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [loadUserGames, user]",
            "fix": { "range": [827, 833], "text": "[loadUserGames, user]" }
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React, { useState, useEffect } from 'react';\nimport { getUserGames, createGame, joinGame, deleteGame } from '../firebase/database';\nimport { parseArmyFile } from '../utils/armyParser';\nimport ConfirmDialog from './ConfirmDialog';\nimport './GameDashboard.css';\n\nconst GameDashboard = ({ user, onJoinGame }) => {\n  const [recentGames, setRecentGames] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [showCreateGame, setShowCreateGame] = useState(false);\n  const [gameId, setGameId] = useState('');\n  const [uploadError, setUploadError] = useState('');\n  const [armyFile, setArmyFile] = useState(null);\n  const [gameName, setGameName] = useState('');\n  const [deleteConfirm, setDeleteConfirm] = useState({ isOpen: false, gameId: null, gameName: '' });\n\n  useEffect(() => {\n    loadUserGames();\n  }, [user]);\n\n  const loadUserGames = async () => {\n    try {\n      const userGames = await getUserGames(user.uid);\n      // Sort by most recent first\n      const sortedGames = userGames.sort((a, b) => \n        new Date(b.createdAt) - new Date(a.createdAt)\n      );\n      setRecentGames(sortedGames);\n    } catch (error) {\n      console.error('Failed to load games:', error);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const handleFileUpload = (event) => {\n    const file = event.target.files[0];\n    if (!file) return;\n\n    setUploadError('');\n    setArmyFile(file);\n  };\n\n  const handleCreateGame = async () => {\n    if (!armyFile || !gameName.trim()) {\n      setUploadError('Please provide a game name and upload an army file');\n      return;\n    }\n\n    try {\n      const text = await armyFile.text();\n      const jsonData = JSON.parse(text);\n      const armyData = parseArmyFile(jsonData);\n\n      const gameData = await createGame({\n        name: gameName.trim(),\n        createdBy: user.uid,\n        players: [user.uid], // Add players array for security rules\n        playerArmies: {\n          [user.uid]: {\n            playerName: user.displayName || user.email,\n            armyData: armyData\n          }\n        }\n      });\n\n      // Reset form\n      setGameName('');\n      setArmyFile(null);\n      setShowCreateGame(false);\n      setUploadError('');\n      \n      // Refresh games list\n      loadUserGames();\n      \n      // Join the newly created game\n      onJoinGame(gameData.id);\n    } catch (error) {\n      console.error('Failed to create game:', error);\n      setUploadError('Failed to create game. Please check your army file format.');\n    }\n  };\n\n  const handleJoinGame = async () => {\n    if (!gameId.trim()) {\n      setUploadError('Please enter a game ID');\n      return;\n    }\n\n    try {\n      await joinGame(gameId.trim(), user.uid, user.displayName || user.email);\n      onJoinGame(gameId.trim());\n      setGameId('');\n      setUploadError('');\n    } catch (error) {\n      console.error('Failed to join game:', error);\n      setUploadError('Failed to join game. Please check the game ID.');\n    }\n  };\n\n  const handleViewGame = (gameId) => {\n    onJoinGame(gameId);\n  };\n\n  const handleDeleteGame = (gameId, gameName) => {\n    setDeleteConfirm({\n      isOpen: true,\n      gameId: gameId,\n      gameName: gameName\n    });\n  };\n\n  const confirmDeleteGame = async () => {\n    try {\n      await deleteGame(deleteConfirm.gameId);\n      setDeleteConfirm({ isOpen: false, gameId: null, gameName: '' });\n      loadUserGames(); // Refresh the list\n    } catch (error) {\n      console.error('Failed to delete game:', error);\n      setUploadError('Failed to delete game. Please try again.');\n    }\n  };\n\n  const cancelDeleteGame = () => {\n    setDeleteConfirm({ isOpen: false, gameId: null, gameName: '' });\n  };\n\n  const formatDate = (dateString) => {\n    return new Date(dateString).toLocaleDateString('en-US', {\n      month: 'short',\n      day: 'numeric',\n      year: 'numeric',\n      hour: '2-digit',\n      minute: '2-digit'\n    });\n  };\n\n  const getGameStatus = (game) => {\n    if (game.status === 'completed') return '✅ Completed';\n    if (game.status === 'active') return '🎮 Active';\n    return '⏸️ Paused';\n  };\n\n  if (loading) {\n    return <div className=\"loading\">Loading games...</div>;\n  }\n\n  return (\n    <div className=\"dashboard-container\">\n      <div className=\"dashboard-header\">\n        <h1 className=\"dashboard-title\">Game Dashboard</h1>\n        <button \n          onClick={() => setShowCreateGame(!showCreateGame)} \n          className=\"new-game-btn\"\n        >\n          {showCreateGame ? 'Cancel' : 'New Game'}\n        </button>\n      </div>\n\n      {showCreateGame && (\n        <div className=\"create-game-form\">\n          <h2 className=\"form-title\">Create New Game</h2>\n          \n          <div className=\"form-group\">\n            <label className=\"form-label\">Game Name</label>\n            <input\n              type=\"text\"\n              value={gameName}\n              onChange={(e) => setGameName(e.target.value)}\n              placeholder=\"Enter game name\"\n              className=\"form-input\"\n            />\n          </div>\n\n          <div className=\"form-group\">\n            <label className=\"form-label\">Army File</label>\n            <div className=\"file-input\" onClick={() => document.getElementById('army-file').click()}>\n              <input\n                id=\"army-file\"\n                type=\"file\"\n                accept=\".json\"\n                onChange={handleFileUpload}\n                style={{ display: 'none' }}\n              />\n              {armyFile ? `Selected: ${armyFile.name}` : 'Click to upload army file (.json)'}\n            </div>\n          </div>\n\n          {uploadError && (\n            <div className=\"error-message\">{uploadError}</div>\n          )}\n\n          <div className=\"form-actions\">\n            <button onClick={() => setShowCreateGame(false)} className=\"cancel-btn\">\n              Cancel\n            </button>\n            <button onClick={handleCreateGame} className=\"create-btn\">\n              Create Game\n            </button>\n          </div>\n        </div>\n      )}\n\n      <div className=\"recent-games-section\">\n        <h2 className=\"section-title\">Recent Games</h2>\n        \n        {recentGames.length === 0 ? (\n          <div className=\"no-games\">\n            <p>No games found. Create your first game to get started!</p>\n          </div>\n        ) : (\n          <div className=\"games-grid\">\n            {recentGames.map((game) => (\n              <div key={game.id} className=\"game-card\">\n                <div className=\"game-card-header\">\n                  <h3 className=\"game-name\">{game.name}</h3>\n                  <span className=\"game-status\">{getGameStatus(game)}</span>\n                </div>\n                \n                <div className=\"game-info\">\n                  Created: {formatDate(game.createdAt)}\n                </div>\n                <div className=\"game-info\">\n                  Players: {Object.keys(game.playerArmies || {}).length}\n                </div>\n                <div className=\"game-info\">\n                  Round: {game.round || 1}\n                </div>\n\n                <div className=\"game-armies\">\n                  {Object.entries(game.playerArmies || {}).map(([playerId, playerArmy]) => (\n                    <div key={playerId} className=\"army-info\">\n                      • {playerArmy.playerName}: {playerArmy.armyData?.name || 'Unknown Army'}\n                      {playerArmy.armyData?.faction && (\n                        <span className=\"faction\"> ({playerArmy.armyData.faction})</span>\n                      )}\n                    </div>\n                  ))}\n                </div>\n\n                <div className=\"game-actions\">\n                  <button \n                    onClick={() => handleViewGame(game.id)}\n                    className=\"action-btn view-btn\"\n                  >\n                    View Game\n                  </button>\n                  {game.createdBy === user.uid && (\n                    <button \n                      onClick={() => handleDeleteGame(game.id, game.name)}\n                      className=\"action-btn delete-btn\"\n                    >\n                      Delete\n                    </button>\n                  )}\n                </div>\n              </div>\n            ))}\n          </div>\n        )}\n      </div>\n\n      <div className=\"join-game-form\">\n        <h3 className=\"join-game-title\">Join Existing Game</h3>\n        <input\n          type=\"text\"\n          value={gameId}\n          onChange={(e) => setGameId(e.target.value)}\n          placeholder=\"Enter Game ID\"\n          className=\"game-id-input\"\n        />\n        <button onClick={handleJoinGame} className=\"join-btn\">\n          Join Game\n        </button>\n      </div>\n\n      <ConfirmDialog\n        isOpen={deleteConfirm.isOpen}\n        title=\"Delete Game\"\n        message={`Are you sure you want to delete \"${deleteConfirm.gameName}\"? This action cannot be undone.`}\n        onConfirm={confirmDeleteGame}\n        onCancel={cancelDeleteGame}\n        isDestructive={true}\n      />\n    </div>\n  );\n};\n\nexport default GameDashboard;\n",
    "usedDeprecatedRules": [
      { "ruleId": "dot-location", "replacedBy": [] },
      { "ruleId": "new-parens", "replacedBy": [] },
      { "ruleId": "no-mixed-operators", "replacedBy": [] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "no-whitespace-before-property", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\John\\Documents\\Code\\tabletop-army-manager\\src\\components\\GameDashboard.old.js",
    "messages": [
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has a missing dependency: 'loadUserGames'. Either include it or remove the dependency array.",
        "line": 19,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 19,
        "endColumn": 12,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [loadUserGames, user]",
            "fix": { "range": [827, 833], "text": "[loadUserGames, user]" }
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React, { useState, useEffect } from 'react';\nimport { getUserGames, createGame, joinGame, deleteGame } from '../firebase/database';\nimport { parseArmyFile } from '../utils/armyParser';\nimport ConfirmDialog from './ConfirmDialog';\nimport './GameDashboard.css';\n\nconst GameDashboard = ({ user, onJoinGame }) => {\n  const [recentGames, setRecentGames] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [showCreateGame, setShowCreateGame] = useState(false);\n  const [gameId, setGameId] = useState('');\n  const [uploadError, setUploadError] = useState('');\n  const [armyFile, setArmyFile] = useState(null);\n  const [gameName, setGameName] = useState('');\n  const [deleteConfirm, setDeleteConfirm] = useState({ isOpen: false, gameId: null, gameName: '' });\n\n  useEffect(() => {\n    loadUserGames();\n  }, [user]);\n\n  const loadUserGames = async () => {\n    try {\n      const userGames = await getUserGames(user.uid);\n      // Sort by most recent first\n      const sortedGames = userGames.sort((a, b) => \n        new Date(b.createdAt) - new Date(a.createdAt)\n      );\n      setRecentGames(sortedGames);\n    } catch (error) {\n      console.error('Failed to load games:', error);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const handleFileUpload = (event) => {\n    const file = event.target.files[0];\n    if (!file) return;\n\n    setUploadError('');\n    setArmyFile(file);\n  };\n\n  const handleCreateGame = async () => {\n    if (!armyFile || !gameName.trim()) {\n      setUploadError('Please provide a game name and upload an army file');\n      return;\n    }\n\n    try {\n      const text = await armyFile.text();\n      const jsonData = JSON.parse(text);\n      \n      // Parse the army file (handles both BattleScribe and simple formats)\n      const parsedArmy = parseArmyFile(jsonData);\n      \n      // Debug: Log parsed army to check weapons\n      console.log('Parsed army data:', JSON.stringify(parsedArmy, null, 2));\n      \n      // Create game with army snapshot\n      const gameData = {\n        name: gameName,\n        players: [user.uid],\n        playerArmies: {\n          [user.uid]: {\n            armyData: parsedArmy, // Snapshot the army data in the game\n            playerId: user.uid,\n            playerName: user.displayName\n          }\n        },\n        gameState: {\n          units: {},\n          damageHistory: {},\n          victoryPoints: {},\n          totalVP: { [user.uid]: 0 },\n          currentTurn: 0,\n          round: 1\n        },\n        status: 'active',\n        createdAt: new Date().toISOString()\n      };\n\n      const newGameId = await createGame(gameData);\n      \n      // Reset form\n      setGameName('');\n      setArmyFile(null);\n      setShowCreateGame(false);\n      document.getElementById('army-file-input').value = '';\n      \n      // Join the new game\n      onJoinGame(newGameId);\n    } catch (error) {\n      console.error('Failed to create game:', error);\n      setUploadError(error.message || 'Failed to create game. Please check the army file format.');\n    }\n  };\n\n  const handleJoinGame = async () => {\n    if (!gameId.trim()) return;\n    \n    try {\n      // For joining existing games, we'll need army data too\n      // For now, just join without army validation\n      await joinGame(gameId, user.uid, null);\n      onJoinGame(gameId);\n    } catch (error) {\n      console.error('Failed to join game:', error);\n      setUploadError('Failed to join game. Please check the Game ID.');\n    }\n  };\n\n  const handleDeleteGame = (game) => {\n    setDeleteConfirm({\n      isOpen: true,\n      gameId: game.id,\n      gameName: game.name\n    });\n  };\n\n  const confirmDeleteGame = async () => {\n    try {\n      await deleteGame(deleteConfirm.gameId);\n      setDeleteConfirm({ isOpen: false, gameId: null, gameName: '' });\n      loadUserGames(); // Refresh the list\n    } catch (error) {\n      console.error('Failed to delete game:', error);\n      setUploadError('Failed to delete game. Please try again.');\n    }\n  };\n\n  const cancelDeleteGame = () => {\n    setDeleteConfirm({ isOpen: false, gameId: null, gameName: '' });\n  };\n\n  const formatDate = (dateString) => {\n    return new Date(dateString).toLocaleDateString('en-US', {\n      month: 'short',\n      day: 'numeric',\n      year: 'numeric',\n      hour: '2-digit',\n      minute: '2-digit'\n    });\n  };\n\n  const getGameStatus = (game) => {\n    if (game.status === 'completed') return '✅ Completed';\n    if (game.status === 'active') return '🎮 Active';\n    return '⏸️ Paused';\n  };\n\n  if (loading) {\n    return <div>Loading games...</div>;\n  }\n\n  return (\n    <div className=\"game-dashboard\">\n      <div className=\"dashboard-header\">\n        <h2>Game Dashboard</h2>\n        <div className=\"dashboard-actions\">\n          <button \n            onClick={() => setShowCreateGame(!showCreateGame)} \n            className=\"create-game-btn\"\n          >\n            {showCreateGame ? 'Cancel' : 'New Game'}\n          </button>\n        </div>\n      </div>\n\n      {uploadError && (\n        <div className=\"error-message\">\n          <p>{uploadError}</p>\n        </div>\n      )}\n\n      {showCreateGame && (\n        <div className=\"create-game-form\">\n          <h3>Create New Game</h3>\n          <div className=\"form-group\">\n            <label htmlFor=\"game-name\">Game Name</label>\n            <input\n              type=\"text\"\n              id=\"game-name\"\n              value={gameName}\n              onChange={(e) => setGameName(e.target.value)}\n              placeholder=\"Enter game name (e.g., 'Tournament Round 1')\"\n              className=\"game-name-input\"\n            />\n          </div>\n          \n          <div className=\"form-group\">\n            <label htmlFor=\"army-file-input\">Upload Your Army</label>\n            <input\n              type=\"file\"\n              accept=\".json\"\n              onChange={handleFileUpload}\n              className=\"file-input\"\n              id=\"army-file-input\"\n            />\n            <label htmlFor=\"army-file-input\" className=\"upload-army-btn\">\n              {armyFile ? `Selected: ${armyFile.name}` : 'Choose Army JSON File'}\n            </label>\n          </div>\n\n          <div className=\"form-actions\">\n            <button onClick={handleCreateGame} className=\"submit-btn\">\n              Create Game\n            </button>\n          </div>\n        </div>\n      )}\n\n      <div className=\"recent-games-section\">\n        <h3>Recent Games</h3>\n        {recentGames.length === 0 ? (\n          <div className=\"no-games\">\n            <p>No games yet. Create your first game to get started!</p>\n            <p>Upload an army file and start tracking your tabletop battles.</p>\n          </div>\n        ) : (\n          <div className=\"games-grid\">\n            {recentGames.map((game) => (\n              <div key={game.id} className=\"game-card\">\n                <div className=\"game-header\">\n                  <h4>{game.name}</h4>\n                  <span className=\"game-status\">{getGameStatus(game)}</span>\n                </div>\n                \n                <div className=\"game-info\">\n                  <p><strong>Created:</strong> {formatDate(game.createdAt)}</p>\n                  <p><strong>Players:</strong> {game.players?.length || 0}</p>\n                  <p><strong>Round:</strong> {game.gameState?.round || 1}</p>\n                </div>\n\n                <div className=\"game-armies\">\n                  <strong>Armies:</strong>\n                  {Object.entries(game.playerArmies || {}).map(([playerId, armyInfo]) => (\n                    <div key={playerId} className=\"army-info\">\n                      <span>{armyInfo.armyData?.name || 'Unknown Army'}</span>\n                      <span className=\"faction\">({armyInfo.armyData?.faction || 'Unknown'})</span>\n                    </div>\n                  ))}\n                </div>\n\n                <div className=\"game-actions\">\n                  <button \n                    onClick={() => onJoinGame(game.id)}\n                    className=\"join-game-btn\"\n                  >\n                    {game.status === 'active' ? 'Continue Game' : 'View Game'}\n                  </button>\n                  <button \n                    onClick={() => handleDeleteGame(game)}\n                    className=\"delete-game-btn\"\n                    title=\"Delete Game\"\n                  >\n                    🗑️\n                  </button>\n                </div>\n              </div>\n            ))}\n          </div>\n        )}\n      </div>\n\n      <div className=\"join-existing-section\">\n        <h3>Join Existing Game</h3>\n        <div className=\"join-game-form\">\n          <input\n            type=\"text\"\n            placeholder=\"Enter Game ID\"\n            value={gameId}\n            onChange={(e) => setGameId(e.target.value)}\n            className=\"game-id-input\"\n          />\n          <button onClick={handleJoinGame} className=\"join-existing-btn\">\n            Join Game\n          </button>\n        </div>\n      </div>\n\n      <ConfirmDialog\n        isOpen={deleteConfirm.isOpen}\n        title=\"Delete Game\"\n        message={`Are you sure you want to delete \"${deleteConfirm.gameName}\"? This action cannot be undone and will permanently remove all game data, including damage history and victory points.`}\n        onConfirm={confirmDeleteGame}\n        onCancel={cancelDeleteGame}\n        confirmText=\"Delete Game\"\n        cancelText=\"Cancel\"\n        isDestructive={true}\n      />\n\n      <style jsx>{`\n        .game-dashboard {\n          max-width: 1200px;\n          margin: 0 auto;\n        }\n\n        .dashboard-header {\n          display: flex;\n          justify-content: space-between;\n          align-items: center;\n          margin-bottom: 2rem;\n        }\n\n        .dashboard-header h2 {\n          margin: 0;\n          color: #2c3e50;\n        }\n\n        .create-game-btn {\n          background: #27ae60;\n          color: white;\n          border: none;\n          padding: 12px 24px;\n          border-radius: 5px;\n          cursor: pointer;\n          font-size: 16px;\n          font-weight: bold;\n        }\n\n        .create-game-btn:hover {\n          background: #219a52;\n        }\n\n        .create-game-form {\n          background: white;\n          padding: 2rem;\n          border-radius: 8px;\n          box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n          margin-bottom: 2rem;\n          border: 2px solid #27ae60;\n        }\n\n        .create-game-form h3 {\n          margin: 0 0 1.5rem 0;\n          color: #2c3e50;\n        }\n\n        .form-group {\n          margin-bottom: 1.5rem;\n        }\n\n        .form-group label {\n          display: block;\n          margin-bottom: 0.5rem;\n          font-weight: bold;\n          color: #34495e;\n        }\n\n        .game-name-input {\n          width: 100%;\n          padding: 12px;\n          border: 1px solid #ddd;\n          border-radius: 4px;\n          font-size: 16px;\n        }\n\n        .file-input {\n          display: none;\n        }\n\n        .upload-army-btn {\n          background: #3498db;\n          color: white;\n          border: none;\n          padding: 12px 20px;\n          border-radius: 4px;\n          cursor: pointer;\n          font-size: 14px;\n          text-decoration: none;\n          display: inline-block;\n          min-width: 200px;\n          text-align: center;\n        }\n\n        .upload-army-btn:hover {\n          background: #2980b9;\n        }\n\n        .form-actions {\n          display: flex;\n          gap: 1rem;\n          justify-content: flex-end;\n        }\n\n        .submit-btn {\n          background: #27ae60;\n          color: white;\n          border: none;\n          padding: 12px 24px;\n          border-radius: 4px;\n          cursor: pointer;\n          font-size: 16px;\n          font-weight: bold;\n        }\n\n        .submit-btn:hover {\n          background: #219a52;\n        }\n\n        .error-message {\n          background: #f8d7da;\n          color: #721c24;\n          padding: 1rem;\n          border-radius: 5px;\n          margin-bottom: 2rem;\n          border: 1px solid #f5c6cb;\n        }\n\n        .error-message p {\n          margin: 0;\n        }\n\n        .recent-games-section {\n          margin-bottom: 3rem;\n        }\n\n        .recent-games-section h3 {\n          margin: 0 0 1.5rem 0;\n          color: #2c3e50;\n        }\n\n        .no-games {\n          text-align: center;\n          padding: 3rem;\n          background: white;\n          border-radius: 8px;\n          color: #666;\n          box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n        }\n\n        .games-grid {\n          display: grid;\n          grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));\n          gap: 1.5rem;\n        }\n\n        .game-card {\n          background: white;\n          padding: 1.5rem;\n          border-radius: 8px;\n          box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n          border: 1px solid #ddd;\n        }\n\n        .game-header {\n          display: flex;\n          justify-content: space-between;\n          align-items: center;\n          margin-bottom: 1rem;\n        }\n\n        .game-header h4 {\n          margin: 0;\n          color: #2c3e50;\n        }\n\n        .game-status {\n          font-size: 12px;\n          padding: 4px 8px;\n          border-radius: 12px;\n          background: #ecf0f1;\n          color: #2c3e50;\n        }\n\n        .game-info {\n          margin-bottom: 1rem;\n        }\n\n        .game-info p {\n          margin: 0.25rem 0;\n          color: #666;\n          font-size: 14px;\n        }\n\n        .game-armies {\n          margin-bottom: 1rem;\n          font-size: 14px;\n          color: #666;\n        }\n\n        .army-info {\n          margin: 0.25rem 0;\n          padding-left: 1rem;\n        }\n\n        .faction {\n          color: #95a5a6;\n          font-style: italic;\n        }\n\n        .game-actions {\n          display: flex;\n          gap: 0.5rem;\n        }\n\n        .join-game-btn {\n          background: #3498db;\n          color: white;\n          border: none;\n          padding: 8px 16px;\n          border-radius: 4px;\n          cursor: pointer;\n          font-size: 14px;\n          flex: 1;\n        }\n\n        .join-game-btn:hover {\n          background: #2980b9;\n        }\n\n        .delete-game-btn {\n          background: #e74c3c;\n          color: white;\n          border: none;\n          padding: 8px 12px;\n          border-radius: 4px;\n          cursor: pointer;\n          font-size: 16px;\n          display: flex;\n          align-items: center;\n          justify-content: center;\n          min-width: 40px;\n        }\n\n        .delete-game-btn:hover {\n          background: #c0392b;\n        }\n\n        .join-existing-section {\n          background: white;\n          padding: 2rem;\n          border-radius: 8px;\n          box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n        }\n\n        .join-existing-section h3 {\n          margin: 0 0 1rem 0;\n          color: #2c3e50;\n        }\n\n        .join-game-form {\n          display: flex;\n          gap: 1rem;\n          align-items: center;\n        }\n\n        .game-id-input {\n          flex: 1;\n          padding: 10px;\n          border: 1px solid #ddd;\n          border-radius: 4px;\n          font-size: 16px;\n        }\n\n        .join-existing-btn {\n          background: #e67e22;\n          color: white;\n          border: none;\n          padding: 10px 20px;\n          border-radius: 4px;\n          cursor: pointer;\n          font-size: 16px;\n        }\n\n        .join-existing-btn:hover {\n          background: #d35400;\n        }\n\n        @media (max-width: 768px) {\n          .dashboard-header {\n            flex-direction: column;\n            gap: 1rem;\n            text-align: center;\n          }\n\n          .games-grid {\n            grid-template-columns: 1fr;\n          }\n\n          .join-game-form {\n            flex-direction: column;\n          }\n\n          .game-id-input {\n            width: 100%;\n          }\n\n          .form-actions {\n            justify-content: center;\n          }\n        }\n      `}</style>\n    </div>\n  );\n};\n\nexport default GameDashboard;\n",
    "usedDeprecatedRules": [
      { "ruleId": "dot-location", "replacedBy": [] },
      { "ruleId": "new-parens", "replacedBy": [] },
      { "ruleId": "no-mixed-operators", "replacedBy": [] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "no-whitespace-before-property", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\John\\Documents\\Code\\tabletop-army-manager\\src\\components\\GameSession.js",
    "messages": [
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'updates' is assigned a value but never used.",
        "line": 100,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 100,
        "endColumn": 17
      },
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'handleAssignDamage' is assigned a value but never used.",
        "line": 235,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 235,
        "endColumn": 27
      },
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'handleAssignVP' is assigned a value but never used.",
        "line": 256,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 256,
        "endColumn": 23
      },
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'handleNextTurn' is assigned a value but never used.",
        "line": 269,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 269,
        "endColumn": 23
      },
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'over' is assigned a value but never used.",
        "line": 325,
        "column": 21,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 325,
        "endColumn": 25
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 5,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React, { useState, useEffect, useMemo, useRef } from 'react';\nimport { DndContext, closestCenter, PointerSensor, useSensor, useSensors, DragOverlay } from '@dnd-kit/core';\nimport { restrictToVerticalAxis, restrictToFirstScrollableAncestor } from '@dnd-kit/modifiers';\nimport { arrayMove, SortableContext, verticalListSortingStrategy, useSortable } from '@dnd-kit/sortable';\nimport { CSS } from '@dnd-kit/utilities';\nimport { updateGameState, subscribeToGame, subscribeToGameUpdates, assignDamage } from '../firebase/database';\n// AuthContext will be implemented later\nimport UnitDatasheet from './UnitDatasheet';\nimport { hasActiveOverrides as ovHasActive, getOverrideSummary as ovSummary, canAttach } from '../utils/eligibility';\n\n// Sortable unit card powered by dnd-kit\nconst SortableUnitBase = ({ unit, isSelected, onClick, statusClass, shouldGlowAsLeader, freezeTransform, dropIntent, titleText, insertEdge, pulse, overrideActive, overrideSummary }) => {\n  const {attributes, listeners, setNodeRef, transform, transition, isDragging} = useSortable({ id: unit.id });\n  const style = {\n    transform: isDragging ? undefined : (freezeTransform ? undefined : CSS.Transform.toString(transform)),\n    transition: isDragging ? undefined : transition,\n    zIndex: isDragging ? 20 : 'auto',\n    opacity: isDragging ? 0 : 1,\n    willChange: isDragging || freezeTransform ? 'auto' : 'transform',\n  };\n\n  return (\n    <div\n      ref={setNodeRef}\n      style={style}\n      className={`unit-card ${isSelected ? 'selected' : ''} ${statusClass} ${dropIntent ? 'leader-drop-intent' : (shouldGlowAsLeader ? 'leader-glow' : '')} ${insertEdge === 'top' ? 'drag-over-before' : ''} ${insertEdge === 'bottom' ? 'drag-over-after' : ''} ${pulse ? 'leader-pulse' : ''}`}\n      data-unit-id={unit.id}\n      title={titleText || undefined}\n      onClick={() => onClick(unit)}\n    >\n      {/* Between-slot overlays for top-level insert targeting */}\n      <div className=\"between-slot top\" aria-hidden=\"true\" data-target-id={unit.id} data-edge=\"top\" data-scope=\"top\"></div>\n      <div className=\"between-slot bottom\" aria-hidden=\"true\" data-target-id={unit.id} data-edge=\"bottom\" data-scope=\"top\"></div>\n      {/* Optional meta row: only when overrides exist, to avoid dead gap */}\n      {overrideActive ? (\n        <div className=\"card-meta\">\n          <span className=\"override-pill\" tabIndex={0} aria-label={overrideSummary} title={overrideSummary}>Overridden</span>\n        </div>\n      ) : null}\n      {/* Drag handle (absolute) with keyboard focus */}\n      <div className=\"drag-handle\" role=\"button\" tabIndex={0} aria-label=\"Drag to reorder\" title=\"Drag to reorder\" {...attributes} {...listeners}>⋮⋮</div>\n      {/* Smaller attach hitbox (visual only) inside the card */}\n      <div className=\"attach-zone\" />\n      <h4>{unit.name}</h4>\n    </div>\n  );\n};\nSortableUnitBase.displayName = 'SortableUnit';\nconst SortableUnit = React.memo(SortableUnitBase);\n\n// Sortable for attached units (to reorder within a leader or detach)\nconst AttachedUnitSortable = ({ unit, isSelected, onClick, statusClass, insertEdge, onDetach, leaderName, leaderId, overrideActive, overrideSummary }) => {\n  const {attributes, listeners, setNodeRef, transform, transition, isDragging} = useSortable({ id: unit.id });\n  const style = {\n    transform: CSS.Transform.toString(transform),\n    transition,\n    zIndex: isDragging ? 20 : 'auto',\n  };\n  const handleKey = (e) => {\n    if (e.key === 'Enter' || e.key === ' ') {\n      e.preventDefault();\n      onDetach?.();\n    }\n  };\n  return (\n    <div\n      ref={setNodeRef}\n      style={style}\n      className={`attached-unit unit-card ${isSelected ? 'selected' : ''} ${statusClass} ${insertEdge === 'top' ? 'drag-over-before' : ''} ${insertEdge === 'bottom' ? 'drag-over-after' : ''}`}\n      onClick={() => onClick(unit)}\n    >\n      {/* Between-slot overlays for child insert targeting */}\n      <div className=\"between-slot top\" aria-hidden=\"true\" data-target-id={unit.id} data-edge=\"top\" data-scope=\"children\" data-leader-id={leaderId}></div>\n      <div className=\"between-slot bottom\" aria-hidden=\"true\" data-target-id={unit.id} data-edge=\"bottom\" data-scope=\"children\" data-leader-id={leaderId}></div>\n      {/* Optional meta row: only when overrides exist */}\n      {overrideActive ? (\n        <div className=\"card-meta\">\n          <span className=\"override-pill\" tabIndex={0} aria-label={overrideSummary} title={overrideSummary}>Overridden</span>\n        </div>\n      ) : null}\n      {/* Drag handle (absolute) with keyboard focus */}\n      <div className=\"drag-handle\" role=\"button\" tabIndex={0} aria-label=\"Drag to reorder\" title=\"Drag to reorder\" {...attributes} {...listeners}>⋮⋮</div>\n      <button\n        type=\"button\"\n        className=\"detach-btn\"\n        aria-label={`Detach from ${leaderName || 'leader'}`}\n        title={`Detach from ${leaderName || 'leader'}`}\n        onClick={(e) => { e.stopPropagation(); onDetach?.(); }}\n        onKeyDown={handleKey}\n      >\n        ×\n      </button>\n      <h4>{unit.name}</h4>\n    </div>\n  );\n};\n\nconst GameSession = ({ gameId, user }) => {\n  const [gameData, setGameData] = useState(null);\n  const [updates, setUpdates] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [selectedUnit, setSelectedUnit] = useState(null);\n  const [damageAmount, setDamageAmount] = useState(1);\n  const [vpAmount, setVpAmount] = useState(1);\n  const [vpReason, setVpReason] = useState('');\n  const [draggedUnit, setDraggedUnit] = useState(null);\n  const [, setOverId] = useState(null);\n  const [unitOrder, setUnitOrder] = useState([]);\n  const [overlayInBounds, setOverlayInBounds] = useState(true);\n  const listRef = useRef(null);\n  const [attachments, setAttachments] = useState({});\n  const [hoveredLeaderId, setHoveredLeaderId] = useState(null);\n  // Unified drag intent store\n  // { type: 'none' } | { type: 'attach', leaderId } | { type: 'insert', id, edge: 'top'|'bottom', scope: 'top'|'children', leaderId?: string }\n  const [dndIntent, setDndIntent] = useState({ type: 'none' });\n  const [pulseLeaderId, setPulseLeaderId] = useState(null);\n  const [leadershipOverrides, setLeadershipOverrides] = useState({});\n  const pointerRef = useRef({ x: 0, y: 0, has: false });\n  const scrollRafRef = useRef(null);\n  const draggingRef = useRef(false);\n  const lastGuideRef = useRef({ id: null, edge: null, scope: 'top', leaderId: null, ts: 0 });\n\n  // Cleanup drag-related UI and listeners\n  const cleanupDragState = () => {\n    setDraggedUnit(null);\n    setOverId(null);\n    setHoveredLeaderId(null);\n    setDndIntent({ type: 'none' });\n    draggingRef.current = false;\n    if (pointerRef.current._onMove) {\n      window.removeEventListener('pointermove', pointerRef.current._onMove);\n      pointerRef.current._onMove = null;\n    }\n    if (scrollRafRef.current) {\n      cancelAnimationFrame(scrollRafRef.current);\n      scrollRafRef.current = null;\n    }\n  };\n\n  useEffect(() => {\n    if (!gameId) return;\n\n    const unsubscribeGame = subscribeToGame(gameId, (gameDoc) => {\n      setGameData(gameDoc);\n      setLoading(false);\n    });\n\n    const unsubscribeUpdates = subscribeToGameUpdates(gameId, (updatesData) => {\n      setUpdates(updatesData);\n    });\n\n    return () => {\n      unsubscribeGame();\n      unsubscribeUpdates();\n    };\n  }, [gameId]);\n\n  // Build full units list (snapshot from gameData)\n  const allUnits = useMemo(() => {\n    if (!gameData) return [];\n    const list = [];\n    if (gameData.playerArmies) {\n      Object.entries(gameData.playerArmies).forEach(([playerId, playerData]) => {\n        if (playerData.armyData && playerData.armyData.units) {\n          playerData.armyData.units.forEach((unit, index) => {\n            list.push({\n              id: `${playerId}_unit_${index}`,\n              name: unit.name || 'Unknown Unit',\n              playerId,\n              playerName: playerData.playerName || 'Unknown Player',\n              currentWounds: unit.currentWounds !== undefined ? unit.currentWounds : (unit.wounds || 1),\n              totalWounds: unit.wounds || 1,\n              totalDamage: unit.totalDamage || 0,\n              victoryPoints: unit.victoryPoints || 0,\n              points: unit.points || 0,\n              models: unit.models || unit.size || 1,\n              // Preserve all unit data\n              movement: unit.movement,\n              weapon_skill: unit.weapon_skill,\n              ballistic_skill: unit.ballistic_skill,\n              strength: unit.strength,\n              toughness: unit.toughness,\n              wounds: unit.wounds,\n              attacks: unit.attacks,\n              leadership: unit.leadership,\n              armor_save: unit.armor_save,\n              invulnerable_save: unit.invulnerable_save,\n              objective_control: unit.objective_control,\n              weapons: unit.weapons || [],\n              modelGroups: unit.modelGroups || [],\n              abilities: unit.abilities || [],\n              rules: unit.rules || [],\n              keywords: unit.keywords || []\n            });\n          });\n        }\n      });\n    }\n    return list;\n  }, [gameData]);\n\n  const allUnitsById = useMemo(() => {\n    const map = {};\n    allUnits.forEach(u => { map[u.id] = u; });\n    return map;\n  }, [allUnits]);\n\n  // Top-level ordered units (exclude attached ones)\n  const orderedUnits = useMemo(() => {\n    const attachedSet = new Set(Object.values(attachments || {}).flat());\n    const baseOrderIds = unitOrder.length > 0 ? unitOrder : allUnits.map(u => u.id);\n    const topIds = baseOrderIds.filter(id => !attachedSet.has(id));\n    return topIds.map(id => allUnitsById[id]).filter(Boolean);\n  }, [allUnits, allUnitsById, unitOrder, attachments]);\n\n  // Reverse lookup: childId -> leaderId for quick checks\n  const unitIsAttachedTo = useMemo(() => {\n    const map = {};\n    Object.entries(attachments || {}).forEach(([leaderId, childArr]) => {\n      (childArr || []).forEach((cid) => { map[cid] = leaderId; });\n    });\n    return map;\n  }, [attachments]);\n\n  // Placeholder approach needs no visual order effect\n\n  // Initialize unit order if not set\n  useEffect(() => {\n    if (unitOrder.length === 0 && orderedUnits.length > 0) {\n      setUnitOrder(orderedUnits.map(unit => unit.id));\n    }\n  }, [unitOrder.length, orderedUnits]);\n\n\n  const handleAssignDamage = async () => {\n    if (!selectedUnit || !damageAmount) return;\n\n    try {\n      const damage = parseInt(damageAmount);\n      const newWounds = Math.max(0, selectedUnit.currentWounds - damage);\n      \n      const damageData = {\n        remainingWounds: newWounds,\n        totalDamage: (selectedUnit.totalDamage || 0) + damage,\n        damageDealt: damage\n      };\n      \n      await assignDamage(gameId, selectedUnit.id, damageData, user.uid);\n      setDamageAmount(1);\n      setSelectedUnit(null);\n    } catch (error) {\n      console.error('Failed to assign damage:', error);\n    }\n  };\n\n  const handleAssignVP = async () => {\n    if (!vpAmount || !vpReason.trim()) return;\n    \n    try {\n      // TODO: Implement assignVictoryPoints function\n      console.log('Assigning VP:', vpAmount, vpReason);\n      setVpAmount(1);\n      setVpReason('');\n    } catch (error) {\n      console.error('Error assigning victory points:', error);\n    }\n  };\n\n  const handleNextTurn = async () => {\n    try {\n      // TODO: Implement nextTurn function\n      console.log('Advancing turn for game:', gameId);\n    } catch (error) {\n      console.error('Error advancing turn:', error);\n    }\n  };\n  // dnd-kit sensors and handlers\n  const sensors = useSensors(useSensor(PointerSensor, { activationConstraint: { distance: 1 } }));\n\n  const itemIds = useMemo(() => orderedUnits.map(u => u.id), [orderedUnits]);\n  \n  const handleDndStart = (event) => {\n    const activeId = event.active?.id;\n    const unit = allUnitsById[activeId] || null;\n    setDraggedUnit(unit);\n    setOverId(null);\n    setHoveredLeaderId(null);\n    setDndIntent({ type: 'none' });\n    setOverlayInBounds(true);\n\n    // Begin pointer tracking & autoscroll\n    draggingRef.current = true;\n    pointerRef.current.has = true;\n    const onMove = (e) => {\n      pointerRef.current.x = e.clientX;\n      pointerRef.current.y = e.clientY;\n    };\n    window.addEventListener('pointermove', onMove, { passive: true });\n    // store handler for removal\n    pointerRef.current._onMove = onMove;\n\n    const autoScrollTick = () => {\n      if (!draggingRef.current) return;\n      const listEl = listRef.current;\n      if (listEl && pointerRef.current.has) {\n        const rect = listEl.getBoundingClientRect();\n        const y = pointerRef.current.y;\n        const zone = 48; // px from edges to start autoscroll\n        let dy = 0;\n        if (y < rect.top + zone) {\n          const intensity = (zone - (y - rect.top)) / zone; // 0..1\n          dy = -Math.ceil(12 * intensity);\n        } else if (y > rect.bottom - zone) {\n          const intensity = (zone - (rect.bottom - y)) / zone;\n          dy = Math.ceil(12 * intensity);\n        }\n        if (dy !== 0) listEl.scrollTop += dy;\n      }\n      scrollRafRef.current = requestAnimationFrame(autoScrollTick);\n    };\n    scrollRafRef.current = requestAnimationFrame(autoScrollTick);\n  };\n\n  const handleDndOver = (event) => {\n    const { active, over } = event;\n    if (!draggedUnit) { setDndIntent({ type: 'none' }); return; }\n\n    // Pointer-driven detection first: between-slot hit\n    const EDGE_PX = 14;\n    const px = pointerRef.current.has ? pointerRef.current.x : (active.rect?.current?.translated?.left || 0) + (active.rect?.current?.translated?.width || 0)/2;\n    const py = pointerRef.current.has ? pointerRef.current.y : (active.rect?.current?.translated?.top || 0) + (active.rect?.current?.translated?.height || 0)/2;\n\n    // Containment: if pointer exits the list container, keep last intent and hide overlay\n    const listEl = listRef.current;\n    const containerEl = listEl ? (listEl.closest('.units-sidebar') || listEl) : null;\n    if (containerEl) {\n      const rect = containerEl.getBoundingClientRect();\n      const inside = px >= rect.left && px <= rect.right && py >= rect.top && py <= rect.bottom;\n      if (!inside) {\n        setOverlayInBounds(false);\n        return; // keep last valid state; do not recompute intent outside\n      }\n      if (!overlayInBounds) setOverlayInBounds(true);\n    }\n    const el = document.elementFromPoint(px, py);\n    const gap = el?.closest('.between-slot');\n    if (gap) {\n      const targetId = gap.getAttribute('data-target-id');\n      const edge = gap.getAttribute('data-edge'); // 'top' | 'bottom'\n      const scope = gap.getAttribute('data-scope') || 'top';\n      const leaderId = gap.getAttribute('data-leader-id');\n      const newGuide = { id: targetId, edge, scope, leaderId: leaderId || null };\n      // Hysteresis: avoid flicker when rapidly crossing midlines\n      const prev = lastGuideRef.current;\n      const now = Date.now();\n      const sameAnchor = prev.id === newGuide.id && prev.scope === newGuide.scope && prev.leaderId === newGuide.leaderId;\n      if (!sameAnchor || prev.edge !== newGuide.edge || (now - prev.ts) > 100) {\n        setDndIntent({ type: 'insert', ...newGuide });\n        lastGuideRef.current = { ...newGuide, ts: now };\n      }\n      // Freeze leader while its edge is hovered\n      const anchorUnit = allUnitsById[targetId];\n      if (anchorUnit && isLeaderUnit(anchorUnit)) setHoveredLeaderId(targetId); else setHoveredLeaderId(null);\n      return;\n    }\n\n    // Next: hover over a card body (center/edges)\n    const card = el?.closest('.unit-card[data-unit-id]');\n    const candidateId = card?.getAttribute('data-unit-id') || null;\n    if (candidateId && candidateId !== String(active.id)) {\n      const candidate = allUnitsById[candidateId];\n      const r = card.getBoundingClientRect();\n      const inTopEdge = py <= r.top + EDGE_PX;\n      const inBottomEdge = py >= r.bottom - EDGE_PX;\n      const inEdges = inTopEdge || inBottomEdge;\n      if (isLeaderUnit(candidate)) {\n        setHoveredLeaderId(candidateId);\n        const eligible = !isLeaderUnit(draggedUnit) && canLeaderAttachToUnit(candidate, draggedUnit);\n        if (inEdges) {\n          const newGuide = { id: candidateId, edge: inTopEdge ? 'top' : 'bottom', scope: 'top', leaderId: null };\n          const prev = lastGuideRef.current; const now = Date.now();\n          const sameAnchor = prev.id === newGuide.id && prev.scope === newGuide.scope;\n          if (!sameAnchor || prev.edge !== newGuide.edge || (now - prev.ts) > 100) {\n            setDndIntent({ type: 'insert', ...newGuide });\n            lastGuideRef.current = { ...newGuide, ts: now };\n          }\n        } else if (eligible) {\n          setDndIntent({ type: 'attach', leaderId: candidateId });\n        } else {\n          const edge = py < (r.top + r.bottom) / 2 ? 'top' : 'bottom';\n          const newGuide = { id: candidateId, edge, scope: 'top', leaderId: null };\n          const prev = lastGuideRef.current; const now = Date.now();\n          const sameAnchor = prev.id === newGuide.id && prev.scope === newGuide.scope;\n          if (!sameAnchor || prev.edge !== newGuide.edge || (now - prev.ts) > 100) {\n            setDndIntent({ type: 'insert', ...newGuide });\n            lastGuideRef.current = { ...newGuide, ts: now };\n          }\n        }\n      } else {\n        const parentLeaderId = unitIsAttachedTo[candidateId] || null;\n        if (parentLeaderId) {\n          // Reorder within same leader's children if applicable\n          if (unitIsAttachedTo[active.id] === parentLeaderId) {\n            const edge = inTopEdge ? 'top' : (inBottomEdge ? 'bottom' : (py < (r.top + r.bottom) / 2 ? 'top' : 'bottom'));\n            const newGuide = { id: candidateId, edge, scope: 'children', leaderId: parentLeaderId };\n            const prev = lastGuideRef.current;\n            const now = Date.now();\n            const sameAnchor = prev.id === newGuide.id && prev.scope === newGuide.scope && prev.leaderId === newGuide.leaderId;\n            if (!sameAnchor || prev.edge !== newGuide.edge || (now - prev.ts) > 100) {\n              setDndIntent({ type: 'insert', ...newGuide });\n              lastGuideRef.current = { ...newGuide, ts: now };\n            }\n            setHoveredLeaderId(parentLeaderId);\n          } else {\n            // Different leader's child; allow only top-level gaps\n            setHoveredLeaderId(null);\n            setDndIntent({ type: 'none' });\n          }\n        } else {\n          // Normal top-level card\n          const edge = inTopEdge ? 'top' : (inBottomEdge ? 'bottom' : (py < (r.top + r.bottom) / 2 ? 'top' : 'bottom'));\n          const newGuide = { id: candidateId, edge, scope: 'top', leaderId: null };\n          const prev = lastGuideRef.current; const now = Date.now();\n          const sameAnchor = prev.id === newGuide.id && prev.scope === newGuide.scope;\n          if (!sameAnchor || prev.edge !== newGuide.edge || (now - prev.ts) > 100) {\n            setDndIntent({ type: 'insert', ...newGuide });\n            lastGuideRef.current = { ...newGuide, ts: now };\n          }\n          setHoveredLeaderId(null);\n        }\n      }\n    } else {\n      setHoveredLeaderId(null);\n      setDndIntent({ type: 'none' });\n    }\n  };\n\n  const handleDndEnd = (event) => {\n    const { active, over } = event;\n    const activeId = active?.id;\n    const overItemId = over?.id;\n    const intent = dndIntent; // capture before clearing\n    // Clear hover state & stop tracking\n    cleanupDragState();\n\n    // If overlay/pointer was out of bounds, snap back (no move)\n    if (!overlayInBounds) {\n      return;\n    }\n\n    const activeUnit = allUnitsById[activeId];\n    // If attach intent was active and valid, perform attach and persist\n    if (intent.type === 'attach' && activeUnit && !isLeaderUnit(activeUnit)) {\n      const leader = allUnitsById[intent.leaderId];\n      if (leader && canLeaderAttachToUnit(leader, activeUnit)) {\n        const next = (() => {\n          const next = { ...(attachments || {}) };\n          // remove from all leaders first\n          Object.keys(next).forEach(lid => {\n            next[lid] = (next[lid] || []).filter(id => id !== activeId);\n            if (next[lid].length === 0) delete next[lid];\n          });\n          // add to this leader if not already present\n          const arr = next[intent.leaderId] || [];\n          if (arr.includes(activeId)) {\n            // reorder within children: move to end\n            next[intent.leaderId] = arr.filter(id => id !== activeId).concat(activeId);\n          } else {\n            arr.push(activeId);\n            next[intent.leaderId] = arr;\n          }\n          return next;\n        })();\n        // Compute new top-level order (remove attached child if present)\n        const newTop = itemIds.filter(id => id !== activeId);\n        setAttachments(next);\n        setUnitOrder(newTop);\n        // persist to Firebase\n        updateGameState(gameId, { 'gameState.attachments': next, 'gameState.unitOrder': newTop }).catch(err => console.error('persist attach failed', err));\n        setPulseLeaderId(intent.leaderId);\n        setTimeout(() => setPulseLeaderId(null), 500);\n        return;\n      }\n    }\n\n    // Reorder using insert guide (respects before/after)\n    if (intent.type === 'insert' && intent.id) {\n      if (intent.scope === 'top') {\n        const wasAttached = !!unitIsAttachedTo[activeId];\n        let next = attachments;\n        if (wasAttached) {\n          // detach from previous leader\n          next = { ...(attachments || {}) };\n          Object.keys(next).forEach(lid => {\n            next[lid] = (next[lid] || []).filter(id => id !== activeId);\n            if (next[lid].length === 0) delete next[lid];\n          });\n          setAttachments(next);\n        }\n        const newTop = itemIds.filter(id => id !== activeId);\n        const anchorIndex = newTop.indexOf(intent.id);\n        if (anchorIndex !== -1) {\n          const insertAt = intent.edge === 'bottom' ? anchorIndex + 1 : anchorIndex;\n          newTop.splice(insertAt, 0, activeId);\n          setUnitOrder(newTop);\n          // persist\n          const update = { 'gameState.unitOrder': newTop };\n          if (wasAttached) update['gameState.attachments'] = next;\n          updateGameState(gameId, update).catch(err => console.error('persist reorder failed', err));\n          return;\n        }\n      } else if (intent.scope === 'children' && intent.leaderId && unitIsAttachedTo[activeId] === intent.leaderId) {\n        // reorder inside leader's children\n        const arr = Array.from(attachments[intent.leaderId] || []);\n        const fromIdx = arr.indexOf(activeId);\n        const anchorIdx = arr.indexOf(intent.id);\n        if (fromIdx !== -1 && anchorIdx !== -1) {\n          const without = arr.filter(id => id !== activeId);\n          const insertAt = intent.edge === 'bottom' ? (anchorIdx + (fromIdx < anchorIdx ? 0 : 1)) : (anchorIdx + (fromIdx < anchorIdx ? -1 : 0));\n          const bounded = Math.max(0, Math.min(without.length, insertAt));\n          without.splice(bounded, 0, activeId);\n          const next = { ...(attachments || {}) };\n          next[intent.leaderId] = without;\n          setAttachments(next);\n          updateGameState(gameId, { 'gameState.attachments': next }).catch(err => console.error('persist child-reorder failed', err));\n          return;\n        }\n      }\n    }\n\n    // Fallback: reorder by over id\n    if (!overItemId || activeId === overItemId) return;\n    const oldIndex = itemIds.indexOf(activeId);\n    const newIndex = itemIds.indexOf(overItemId);\n    if (oldIndex === -1 || newIndex === -1) return;\n    const newTopOrder = arrayMove(itemIds, oldIndex, newIndex);\n    setUnitOrder(newTopOrder);\n    updateGameState(gameId, { 'gameState.unitOrder': newTopOrder }).catch(err => console.error('persist reorder failed', err));\n  };\n\n  // Sync attachments from backend\n  useEffect(() => {\n    const backend = gameData?.gameState?.attachments || {};\n    setAttachments(backend);\n  }, [gameData?.gameState?.attachments]);\n\n  // Sync unit order from backend\n  useEffect(() => {\n    const backendOrder = gameData?.gameState?.unitOrder;\n    if (Array.isArray(backendOrder) && backendOrder.length) {\n      setUnitOrder(backendOrder);\n    }\n  }, [gameData?.gameState?.unitOrder]);\n\n  // Sync leadership overrides from backend\n  useEffect(() => {\n    const backend = gameData?.gameState?.leadershipOverrides || {};\n    setLeadershipOverrides(backend);\n  }, [gameData?.gameState?.leadershipOverrides]);\n\n  // Detach helper for detach button\n  const detachUnit = (leaderId, childId) => {\n    setAttachments(prev => {\n      const next = { ...(prev || {}) };\n      if (next[leaderId]) {\n        next[leaderId] = (next[leaderId] || []).filter(id => id !== childId);\n        if (next[leaderId].length === 0) delete next[leaderId];\n      }\n      // Insert the child below the leader in the top-level order\n      const top = itemIds.slice();\n      const leaderIdx = top.indexOf(leaderId);\n      const insertAt = leaderIdx >= 0 ? leaderIdx + 1 : top.length;\n      // ensure child not present (it won't be in top yet)\n      const newTop = top.filter(id => id !== childId);\n      newTop.splice(insertAt, 0, childId);\n      setUnitOrder(newTop);\n      updateGameState(gameId, { 'gameState.attachments': next, 'gameState.unitOrder': newTop }).catch(err => console.error('persist detach failed', err));\n      return next;\n    });\n  };\n\n  // Update overrides for a unit and persist\n  const updateUnitOverrides = (unitId, partial) => {\n    setLeadershipOverrides(prev => {\n      const next = { ...(prev || {}) };\n      const current = next[unitId] || { canLead: 'auto', canBeLed: 'auto', allowList: [] };\n      const merged = {\n        ...current,\n        ...partial,\n        allowList: partial.allowList !== undefined ? Array.from(new Set(partial.allowList)) : current.allowList,\n      };\n      next[unitId] = merged;\n      updateGameState(gameId, { 'gameState.leadershipOverrides': next }).catch(err => console.error('persist overrides failed', err));\n      return next;\n    });\n  };\n\n  // Helper functions for new unit status system\n  const getUnitStatusClass = (unit) => {\n    if (unit.currentWounds === 0) return 'dead';\n    if (unit.hasActed) return 'done'; // Assuming we'll add this field\n    return 'ready';\n  };\n\n  //\n\n  // Quick leader check for visuals (orange glow)\n  const isLeaderUnit = (unit) => {\n    if (!unit) return false;\n    const ov = leadershipOverrides[unit.id];\n    if (ov?.canLead === 'yes') return true;\n    if (ov?.canLead === 'no') return false;\n    const keywords = (unit.keywords || []).map(k => String(k).toLowerCase());\n    const rules = (unit.rules || []).map(r => String(r).toLowerCase());\n    const abilities = unit.abilities || [];\n    const name = String(unit.name || '').toLowerCase();\n\n    const hasLeaderKeyword = keywords.includes('leader');\n    const hasCharacterKeyword = keywords.includes('character');\n    const hasLeaderRule = rules.some(r => r.includes('leader'));\n    const hasLeaderAbility = abilities.some(a => String(a.name || '').toLowerCase().includes('leader'));\n    const hasAttachText = abilities.some(a => String(a.description || a.text || '').toLowerCase().includes('this model can be attached to'));\n\n    const commonLeaderNames = ['captain','commander','lieutenant','librarian','chaplain','ancient','champion','sanguinary','priest','company master','apothecary','judiciar'];\n    const isCommonLeaderName = commonLeaderNames.some(n => name.includes(n));\n\n    return hasLeaderKeyword || hasCharacterKeyword || hasLeaderRule || hasLeaderAbility || hasAttachText || isCommonLeaderName;\n  };\n\n  // Baseline source-data check (strict, from abilities text)\n  const sourceCanAttach = (leader, draggedUnit) => {\n    if (!leader || !draggedUnit) return false;\n    // Must actually have a Leader ability\n    const abilities = leader.abilities || [];\n    const hasLeaderAbility = abilities.some(a => String(a.name || '').toLowerCase().includes('leader'));\n    if (!hasLeaderAbility) return false;\n\n    const normalize = (s) => String(s || '')\n      .toLowerCase()\n      .replace(/[^a-z0-9\\s]/g, ' ')\n      .replace(/\\s+/g, ' ')\n      .trim();\n\n    const unitFull = normalize(draggedUnit.name);\n    // Try without trailing \"with ...\" qualifiers for broader matching\n    const unitBase = normalize(draggedUnit.name.replace(/\\bwith\\b.*$/, ''));\n\n    // Look for explicit attach permission mentioning the target unit\n    return abilities.some(ability => {\n      const name = normalize(ability.name);\n      const text = normalize(ability.description || ability.text);\n      if (!(name.includes('leader') || text.includes('this model can be attached to') || text.includes('can be attached to'))) {\n        return false;\n      }\n      // Must reference the unit by name (full or base)\n      return text.includes(unitFull) || text.includes(unitBase);\n    });\n  };\n\n  // Centralized eligibility helpers are imported from ../utils/eligibility\n  const canLeaderAttachToUnit = (leader, draggedUnit) => {\n    return canAttach(leader, draggedUnit, leadershipOverrides, sourceCanAttach);\n  };\n\n\n  if (loading) {\n    return <div>Loading...</div>;\n  }\n\n  if (!gameData) {\n    return <div className=\"error\">Game not found</div>;\n  }\n\n\n\n  // Determine whose turn it is\n  const isMyTurn = gameData.currentTurn === user?.uid;\n\n  return (\n    <div className=\"game-session\">\n      <div className=\"game-header\">\n        <h2>{gameData.name}</h2>\n        <div className=\"game-info\">\n          <span>Round: {gameData.round || 1}</span>\n          <span>Current Turn: {isMyTurn ? 'Your Turn' : 'Waiting...'}</span>\n          <span>Game ID: {gameId}</span>\n        </div>\n      </div>\n\n      <div className=\"game-content\">\n        <div className=\"units-sidebar\">\n          <h3>{user?.displayName || user?.email || 'Player'}'s Army</h3>\n          \n          {/* Status Legend */}\n          <div className=\"status-legend\">\n            <div className=\"legend-item\">\n              <div className=\"legend-color ready\"></div>\n              <span>Ready</span>\n            </div>\n            <div className=\"legend-item\">\n              <div className=\"legend-color done\"></div>\n              <span>Done</span>\n            </div>\n            <div className=\"legend-item\">\n              <div className=\"legend-color dead\"></div>\n              <span>Dead</span>\n            </div>\n          </div>\n          \n          <DndContext\n            sensors={sensors}\n            collisionDetection={closestCenter}\n            modifiers={[restrictToVerticalAxis, restrictToFirstScrollableAncestor]}\n            onDragStart={handleDndStart}\n            onDragOver={handleDndOver}\n            onDragEnd={handleDndEnd}\n            onDragCancel={cleanupDragState}\n          >\n            <SortableContext items={itemIds} strategy={verticalListSortingStrategy}>\n              <div className=\"units-list\" ref={listRef}>\n                {orderedUnits.map((unit, idx) => {\n                  const shouldGlowAsLeader = !!draggedUnit && isLeaderUnit(unit) && draggedUnit.id !== unit.id && canLeaderAttachToUnit(unit, draggedUnit);\n                  const freezeTransform = !!(hoveredLeaderId === unit.id || (dndIntent.type === 'insert' && dndIntent.scope === 'top' && dndIntent.id === unit.id));\n                  const dropIntent = !!(dndIntent.type === 'attach' && dndIntent.leaderId === unit.id);\n                  const insertEdge = (dndIntent.type === 'insert' && dndIntent.scope === 'top' && dndIntent.id === unit.id) ? dndIntent.edge : null;\n                  const titleText = dropIntent\n                    ? `Attach to ${unit.name}`\n                    : (insertEdge ? 'Drop to reorder' : undefined);\n                  const ov = leadershipOverrides[unit.id] || {};\n                  const overrideActive = ovHasActive(ov);\n                  const overrideSummary = ovSummary(ov, (id) => allUnitsById[id]?.name || id);\n                  return (\n                    <React.Fragment key={unit.id}>\n                      <SortableUnit\n                        unit={unit}\n                        isSelected={selectedUnit?.id === unit.id}\n                        onClick={setSelectedUnit}\n                        statusClass={getUnitStatusClass(unit)}\n                        shouldGlowAsLeader={!!shouldGlowAsLeader}\n                        freezeTransform={freezeTransform}\n                        dropIntent={dropIntent}\n                        insertEdge={insertEdge}\n                        titleText={titleText}\n                        pulse={pulseLeaderId === unit.id}\n                        overrideActive={overrideActive}\n                        overrideSummary={overrideSummary}\n                      />\n                      {attachments[unit.id] && attachments[unit.id].length > 0 && (\n                        <div className=\"attached-units\">\n                          <SortableContext items={attachments[unit.id]} strategy={verticalListSortingStrategy}>\n                            {attachments[unit.id].map((attachedId) => {\n                              const au = allUnitsById[attachedId];\n                              if (!au) return null;\n                              const childInsert = (dndIntent.type === 'insert' && dndIntent.scope === 'children' && dndIntent.id === attachedId) ? dndIntent.edge : null;\n                              const childOv = leadershipOverrides[attachedId] || {};\n                              const childOverrideActive = ovHasActive(childOv);\n                              const childOverrideSummary = ovSummary(childOv, (id) => allUnitsById[id]?.name || id);\n                              return (\n                                <React.Fragment key={attachedId}>\n                                  <AttachedUnitSortable\n                                    unit={au}\n                                    isSelected={selectedUnit?.id === attachedId}\n                                    onClick={setSelectedUnit}\n                                    statusClass={getUnitStatusClass(au)}\n                                    insertEdge={childInsert}\n                                    leaderName={unit.name}\n                                    leaderId={unit.id}\n                                    onDetach={() => detachUnit(unit.id, attachedId)}\n                                    overrideActive={childOverrideActive}\n                                    overrideSummary={childOverrideSummary}\n                                  />\n                                </React.Fragment>\n                              );\n                            })}\n                          </SortableContext>\n                        </div>\n                      )}\n                    </React.Fragment>\n                  );\n                })}\n              </div>\n            </SortableContext>\n            <DragOverlay adjustScale={false} dropAnimation={null}>\n              {draggedUnit && overlayInBounds ? (\n                <div className={`unit-card dragging ${getUnitStatusClass(draggedUnit)} ${selectedUnit?.id === draggedUnit.id ? 'selected' : ''}`} style={{ pointerEvents: 'none', cursor: 'grabbing', boxShadow: '0 10px 20px rgba(0,0,0,0.25)', border: '2px solid var(--action-primary)' }}>\n                  <div className=\"drag-handle\" title=\"Drag to reorder\">⋮⋮</div>\n                  <h4>{draggedUnit.name}</h4>\n                </div>\n              ) : null}\n            </DragOverlay>\n          </DndContext>\n        </div>\n\n        <div className=\"game-main\">\n          {selectedUnit ? (\n            <UnitDatasheet\n              unit={selectedUnit}\n              isSelected={true}\n              onClick={() => {}}\n              overrides={leadershipOverrides[selectedUnit.id] || { canLead: 'auto', canBeLed: 'auto', allowList: [] }}\n              allUnits={allUnits}\n              onUpdateOverrides={(partial) => updateUnitOverrides(selectedUnit.id, partial)}\n            />\n          ) : (\n            <div className=\"no-unit-selected\">\n              <h3>Select a unit from the sidebar to view details</h3>\n              <p>Click on any unit in your army list to see its datasheet and available actions.</p>\n            </div>\n          )}\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default GameSession;\n",
    "usedDeprecatedRules": [
      { "ruleId": "dot-location", "replacedBy": [] },
      { "ruleId": "new-parens", "replacedBy": [] },
      { "ruleId": "no-mixed-operators", "replacedBy": [] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "no-whitespace-before-property", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\John\\Documents\\Code\\tabletop-army-manager\\src\\components\\GameSession.old.js",
    "messages": [
      {
        "ruleId": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Unexpected token (245:4)",
        "line": 245,
        "column": 4,
        "nodeType": null
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React, { useState, useEffect } from 'react';\nimport { useParams } from 'react-router-dom';\nimport { getGame, updateGame, subscribeToGame, subscribeToGameUpdates, assignDamage } from '../firebase/database';\n// AuthContext will be implemented later\nimport UnitDatasheet from './UnitDatasheet';\n\nconst GameSession = ({ gameId, user }) => {\n  const [gameData, setGameData] = useState(null);\n  const [updates, setUpdates] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [selectedUnit, setSelectedUnit] = useState(null);\n  const [damageAmount, setDamageAmount] = useState(1);\n  const [vpAmount, setVpAmount] = useState(1);\n  const [vpReason, setVpReason] = useState('');\n  const [draggedUnit, setDraggedUnit] = useState(null);\n  const [draggedOverIndex, setDraggedOverIndex] = useState(null);\n  const [unitOrder, setUnitOrder] = useState([]);\n\n  useEffect(() => {\n    // Subscribe to game data changes\n    const unsubscribeGame = subscribeToGame(gameId, (data) => {\n      setGameData(data);\n      setLoading(false);\n    });\n\n    // Subscribe to real-time updates\n    const unsubscribeUpdates = subscribeToGameUpdates(gameId, (updatesData) => {\n      setUpdates(updatesData.slice(0, 10)); // Show last 10 updates\n    });\n\n    return () => {\n      unsubscribeGame();\n      unsubscribeUpdates();\n    };\n  }, [gameId]);\n\n  const handleAssignDamage = async () => {\n    if (!selectedUnit || !damageAmount) return;\n\n    try {\n      const damage = parseInt(damageAmount);\n      const newWounds = Math.max(0, selectedUnit.currentWounds - damage);\n      \n      const damageData = {\n        remainingWounds: newWounds,\n        totalDamage: (selectedUnit.totalDamage || 0) + damage,\n        damageDealt: damage\n      };\n      \n      await assignDamage(gameId, selectedUnit.id, damageData, user.uid);\n      setDamageAmount(1);\n      setSelectedUnit(null);\n    } catch (error) {\n      console.error('Failed to assign damage:', error);\n    }\n  };\n\n  const handleAssignVP = async () => {\n    if (!vpAmount || !vpReason.trim()) return;\n    \n    try {\n      // TODO: Implement assignVictoryPoints function\n      console.log('Assigning VP:', vpAmount, vpReason);\n      setVpAmount(1);\n      setVpReason('');\n    } catch (error) {\n      console.error('Error assigning victory points:', error);\n    }\n  };\n\n  const handleNextTurn = async () => {\n    try {\n      // TODO: Implement nextTurn function\n      console.log('Advancing turn for game:', gameId);\n    } catch (error) {\n      console.error('Error advancing turn:', error);\n    }\n  };\n\n  const handleDragStart = (e, unit) => {\n    setDraggedUnit(unit);\n    e.dataTransfer.effectAllowed = 'move';\n    e.dataTransfer.setData('text/html', unit.id);\n  };\n\n  const handleDragEnd = (e) => {\n    setDraggedUnit(null);\n    setDraggedOverIndex(null);\n  };\n\n  const handleDragOver = (e, index) => {\n    e.preventDefault();\n    e.dataTransfer.dropEffect = 'move';\n    setDraggedOverIndex(index);\n  };\n\n  const handleDragLeave = (e) => {\n    // Only clear if we're leaving the unit card entirely\n    if (!e.currentTarget.contains(e.relatedTarget)) {\n      setDraggedOverIndex(null);\n    }\n  };\n\n  const handleDrop = (e, dropIndex) => {\n    e.preventDefault();\n    \n    if (draggedUnit && dropIndex !== undefined) {\n      const draggedIndex = orderedUnits.findIndex(unit => unit.id === draggedUnit.id);\n      \n      if (draggedIndex !== dropIndex) {\n        const newOrder = [...orderedUnits];\n        const [draggedItem] = newOrder.splice(draggedIndex, 1);\n        newOrder.splice(dropIndex, 0, draggedItem);\n        \n        // Update the unit order state\n        setUnitOrder(newOrder.map(unit => unit.id));\n        console.log(`Reordered: moved ${draggedUnit.name} to position ${dropIndex + 1}`);\n      }\n    }\n    \n    setDraggedUnit(null);\n    setDraggedOverIndex(null);\n  };\n\n  if (loading) {\n    return <div>Loading game session...</div>;\n  }\n\n  if (!gameData) {\n    return <div>Game not found</div>;\n  }\n\n  const currentPlayerIndex = gameData.currentTurn || 0;\n  const currentPlayer = gameData.players[currentPlayerIndex];\n  const isMyTurn = currentPlayer === user.uid;\n\n  // Get all units from player armies using actual army data\n  const allUnits = [];\n  \n  Object.entries(gameData.playerArmies || {}).forEach(([playerId, playerArmy]) => {\n    if (playerArmy.armyData && playerArmy.armyData.units) {\n      playerArmy.armyData.units.forEach((unit, index) => {\n        allUnits.push({\n          id: `${playerId}_unit_${index}`,\n          name: unit.name || 'Unknown Unit',\n          playerId,\n          playerName: playerArmy.playerName || 'Unknown Player',\n          currentWounds: unit.wounds || 1,\n          totalWounds: unit.wounds || 1,\n          totalDamage: 0,\n          points: unit.points || 0,\n          models: unit.models || unit.size || 1,\n          weapons: unit.weapons || [],\n          modelGroups: unit.modelGroups || [],\n          abilities: unit.abilities || [],\n          rules: unit.rules || [],\n          keywords: unit.keywords || [],\n          // Include all unit stats\n          weapon_skill: unit.weapon_skill,\n          ballistic_skill: unit.ballistic_skill,\n          toughness: unit.toughness,\n          armor_save: unit.armor_save,\n          invulnerable_save: unit.invulnerable_save\n        });\n      });\n    }\n  });\n\n  // Initialize unit order if not set\n  if (unitOrder.length === 0 && allUnits.length > 0) {\n    setUnitOrder(allUnits.map(unit => unit.id));\n  }\n\n  // Create ordered units array based on unitOrder state\n  const orderedUnits = unitOrder.length > 0 \n    ? unitOrder.map(id => allUnits.find(unit => unit.id === id)).filter(Boolean)\n    : allUnits;\n\n  return (\n    <div className=\"game-session\">\n      <div className=\"game-header\">\n        <h2>{gameData.name}</h2>\n        <div className=\"game-info\">\n          <span>Round: {gameData.round || 1}</span>\n          <span>Current Turn: {isMyTurn ? 'Your Turn' : 'Waiting...'}</span>\n          <span>Game ID: {gameId}</span>\n        </div>\n      </div>\n\n      <div className=\"game-content\">\n        <div className=\"units-sidebar\">\n          <h3>Army Units</h3>\n          <div className=\"units-list\">\n            {orderedUnits.map((unit, index) => (\n              <div \n                key={unit.id}\n                className={`unit-card ${selectedUnit?.id === unit.id ? 'selected' : ''} ${draggedUnit?.id === unit.id ? 'dragging' : ''} ${draggedOverIndex === index ? 'drag-over' : ''}`}\n                onClick={() => setSelectedUnit(unit)}\n                onDragOver={(e) => handleDragOver(e, index)}\n                onDragLeave={handleDragLeave}\n                onDrop={(e) => handleDrop(e, index)}\n              >\n                <div \n                  className=\"drag-handle\"\n                  draggable={true}\n                  onDragStart={(e) => handleDragStart(e, unit)}\n                  onDragEnd={handleDragEnd}\n                  title=\"Drag to reorder\"\n                >\n                  ⋮⋮\n                </div>\n                <h4>{unit.name}</h4>\n                <div className=\"unit-status\">\n                  {unit.currentWounds === 0 ? '💀 Destroyed' : \n                   isMyTurn && unit.playerId === user.uid ? '⚡ Ready' : '⏸️ Waiting'}\n                </div>\n                <div className=\"unit-player\">\n                  {unit.playerName}\n                </div>\n              </div>\n            ))}\n          </div>\n        </div>\n\n        <div className=\"game-main\">\n          {/* Selected Unit Datasheet - Direct display */}\n          {selectedUnit ? (\n            <UnitDatasheet\n              unit={selectedUnit}\n              isSelected={true}\n              onClick={() => {}} // No click action needed here\n            />\n          ) : (\n            <div className=\"no-unit-selected\">\n              <h3>Select a unit from the sidebar to view details</h3>\n              <p>Click on any unit in the Army Units list to see its datasheet and available actions.</p>\n            </div>\n          )}\n        </div>\n      </div>\n    );\n  };\n\n  if (loading) {\n    return <div className=\"loading\">Loading game...</div>;\n  }\n\n  if (!gameData) {\n    return <div className=\"error\">Game not found</div>;\n  }\n\n  return (\n    <div className=\"game-session\">\n      {renderGameContent()}\n    </div>\n  );\n};\n\nexport default GameSession;\n                    <div className=\"unit-keywords\">\n                      <h5>Keywords:</h5>\n                      <div className=\"keywords-list\">\n                        {selectedUnit.keywords.map((keyword, index) => (\n                          <span key={index} className=\"keyword-tag\">{keyword}</span>\n                        ))}\n                      </div>\n                    </div>\n                  )}\n                  \n                  <div className=\"model-groups-section\">\n                    <h5>Model Groups:</h5>\n                    {selectedUnit.weapons && selectedUnit.weapons.length > 0 ? (\n                      (() => {\n                        // Debug logging\n                        console.log('=== GAME SESSION DEBUG ===');\n                        console.log('Selected Unit:', selectedUnit.name);\n                        console.log('Total Models:', selectedUnit.models);\n                        console.log('Weapons Array:', selectedUnit.weapons);\n                        console.log('Model Groups:', selectedUnit.modelGroups);\n                        console.log('Has Model Groups:', selectedUnit.modelGroups && selectedUnit.modelGroups.length > 0);\n                        if (selectedUnit.modelGroups) {\n                          selectedUnit.modelGroups.forEach((group, i) => {\n                            console.log(`Group ${i + 1}: ${group.count}x ${group.name}`);\n                            console.log('  Weapons:', group.weapons);\n                          });\n                        }\n                        console.log('=== END DEBUG ===');\n                        \n                        const totalModels = selectedUnit.models || 1;\n                        const modelGroupCards = [];\n                        \n                        // Check if unit has model groups (sergeant + standard marines)\n                        console.log('Checking modelGroups condition:', {\n                          hasModelGroups: !!selectedUnit.modelGroups,\n                          modelGroupsLength: selectedUnit.modelGroups ? selectedUnit.modelGroups.length : 0,\n                          modelGroups: selectedUnit.modelGroups\n                        });\n                        \n                        if (selectedUnit.modelGroups && selectedUnit.modelGroups.length > 0) {\n                          console.log('✅ Using model groups from parser');\n                          // Use the model groups from the parser\n                          selectedUnit.modelGroups.forEach((modelGroup, index) => {\n                            console.log(`Creating model group ${index + 1}:`, modelGroup);\n                            const weaponsWithCount = modelGroup.weapons.map(weapon => ({\n                              ...weapon,\n                              modelCount: weapon.count || 1\n                            }));\n                            \n                            modelGroupCards.push({\n                              count: modelGroup.count,\n                              weapons: weaponsWithCount,\n                              name: modelGroup.name // Use the exact name from the parser\n                            });\n                          });\n                        } else {\n                          console.log('❌ Falling back to old logic');\n                          // Fallback for single model units or units without model groups\n                          if (totalModels === 1 || totalModels === 0) {\n                            modelGroupCards.push({\n                              count: 1,\n                              weapons: selectedUnit.weapons,\n                              name: selectedUnit.name.replace(/ with.*$/, '')\n                            });\n                          } else {\n                            // For multi-model units, use pre-grouped weapons from parser\n                            const weaponsWithCount = selectedUnit.weapons.map(weapon => ({\n                              ...weapon,\n                              modelCount: weapon.count || 1\n                            }));\n                            \n                            modelGroupCards.push({\n                              count: totalModels,\n                              weapons: weaponsWithCount,\n                              name: selectedUnit.name.replace(/s$/, '').replace(/ with.*$/, '')\n                            });\n                          }\n                        }\n                        \n                        console.log('Model Group Cards:', modelGroupCards);\n                        \n                        return modelGroupCards.map((group, index) => (\n                          <div key={index} className=\"model-group-card\">\n                            <h6>{group.count}x {group.name}{group.count > 1 ? 's' : ''}</h6>\n                            {group.weapons.map((weapon, weaponIndex) => (\n                              <div key={weaponIndex} className=\"weapon-entry\">\n                                <div className=\"weapon-name\">\n                                  • {weapon.name || 'Unknown Weapon'}\n                                  {weapon.modelCount && weapon.modelCount > 1 && (\n                                    <span className=\"weapon-count\"> (x{weapon.modelCount})</span>\n                                  )}\n                                </div>\n                                <div className=\"weapon-stats\">\n                                  {weapon.range && <span>Range: {weapon.range}</span>}\n                                  {weapon.attacks && <span>A: {weapon.attacks}</span>}\n                                  {weapon.skill && <span>WS/BS: {weapon.skill}</span>}\n                                  {weapon.strength && <span>S: {weapon.strength}</span>}\n                                  {weapon.ap && <span>AP: {weapon.ap}</span>}\n                                  {weapon.damage && <span>D: {weapon.damage}</span>}\n                                </div>\n                                {weapon.abilities && weapon.abilities.length > 0 && (\n                                  <div className=\"weapon-abilities\">\n                                    <em>{weapon.abilities.join(', ')}</em>\n                                  </div>\n                                )}\n                              </div>\n                            ))}\n                          </div>\n                        ));\n                      })()\n                    ) : (\n                      <div className=\"model-group-card\">\n                        <h6>{selectedUnit.models || 1}x {selectedUnit.name}</h6>\n                        <p>No weapons found for this unit.</p>\n                      </div>\n                    )}\n                  </div>\n                </div>\n              )}\n            </div>\n\n            <div className=\"action-group\">\n              <h4>Award Victory Points</h4>\n              <div className=\"action-controls\">\n                <input\n                  type=\"number\"\n                  min=\"1\"\n                  value={vpAmount}\n                  onChange={(e) => setVpAmount(e.target.value)}\n                  placeholder=\"VP amount\"\n                />\n                <input\n                  type=\"text\"\n                  value={vpReason}\n                  onChange={(e) => setVpReason(e.target.value)}\n                  placeholder=\"Reason (e.g., 'Destroyed enemy unit')\"\n                />\n                <button \n                  onClick={handleAssignVP}\n                  disabled={!isMyTurn || !vpReason.trim()}\n                  className=\"action-btn vp-btn\"\n                >\n                  Award VP\n                </button>\n              </div>\n            </div>\n\n            <div className=\"action-group\">\n              <button \n                onClick={handleNextTurn}\n                disabled={!isMyTurn}\n                className=\"action-btn next-turn-btn\"\n              >\n                End Turn\n              </button>\n            </div>\n          </div>\n        </div>\n\n        <div className=\"game-sidebar\">\n          <div className=\"victory-points\">\n            <h3>Victory Points</h3>\n            {Object.entries(gameData.gameState?.totalVP || {}).map(([playerId, vp]) => (\n              <div key={playerId} className=\"vp-entry\">\n                <span>Player {playerId.slice(0, 8)}...</span>\n                <span>{vp} VP</span>\n              </div>\n            ))}\n          </div>\n\n          <div className=\"recent-updates\">\n            <h3>Recent Updates</h3>\n            <div className=\"updates-list\">\n              {updates.map((update) => (\n                <div key={update.id} className=\"update-item\">\n                  <div className=\"update-type\">{update.type}</div>\n                  <div className=\"update-details\">\n                    {update.type === 'damage' && `${update.damage} damage to unit`}\n                    {update.type === 'victory_points' && `+${update.points} VP: ${update.reason}`}\n                    {update.type === 'turn_change' && `Turn advanced to Round ${update.round}`}\n                  </div>\n                </div>\n              ))}\n            </div>\n          </div>\n        </div>\n      </div>\n\n      <style jsx>{`\n        .game-session {\n          max-width: 1400px;\n          margin: 0 auto;\n        }\n\n        .game-header {\n          background: white;\n          padding: 1.5rem;\n          border-radius: 8px;\n          margin-bottom: 2rem;\n          box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n        }\n\n        .game-header h2 {\n          margin: 0 0 1rem 0;\n          color: #2c3e50;\n        }\n\n        .game-info {\n          display: flex;\n          gap: 2rem;\n          color: #666;\n        }\n\n        .game-content {\n          display: grid;\n          grid-template-columns: 300px 1fr 300px;\n          gap: 2rem;\n        }\n\n        .units-sidebar {\n          background: white;\n          border-radius: 8px;\n          box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n          height: fit-content;\n          max-height: 80vh;\n          overflow: hidden;\n          display: flex;\n          flex-direction: column;\n        }\n\n        .units-sidebar h3 {\n          margin: 0;\n          color: #2c3e50;\n          background: white;\n          padding: 1.5rem 1.5rem 1rem 1.5rem;\n          flex-shrink: 0;\n          border-bottom: 1px solid #eee;\n        }\n\n        .units-list {\n          display: flex;\n          flex-direction: column;\n          gap: 1rem;\n          padding: 1rem 1.5rem 1.5rem 1.5rem;\n          overflow-y: auto;\n          flex: 1;\n        }\n\n        .game-main {\n          display: flex;\n          flex-direction: column;\n          gap: 2rem;\n        }\n\n        .actions-section {\n          background: white;\n          padding: 1.5rem;\n          border-radius: 8px;\n          box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n        }\n\n        .actions-section h3 {\n          margin: 0 0 1rem 0;\n          color: #2c3e50;\n        }\n\n        .unit-card {\n          border: 2px solid #ddd;\n          padding: 0.75rem;\n          border-radius: 6px;\n          cursor: pointer;\n          transition: all 0.3s;\n          font-size: 0.9rem;\n          background: white;\n          z-index: 1;\n        }\n\n        .unit-card h4 {\n          margin: 0 0 0.5rem 0;\n          font-size: 1rem;\n          color: #2c3e50;\n        }\n\n        .unit-card p {\n          margin: 0.25rem 0;\n          font-size: 0.85rem;\n        }\n\n        .unit-card:hover {\n          border-color: #3498db;\n        }\n\n        .unit-card.selected {\n          border-color: #e74c3c;\n          background: #fdf2f2;\n        }\n\n        .unit-card h4 {\n          margin: 0 0 0.5rem 0;\n          color: #2c3e50;\n        }\n\n        .unit-card p {\n          margin: 0.25rem 0;\n          color: #666;\n          font-size: 14px;\n        }\n\n        .unit-status {\n          margin-top: 0.5rem;\n          font-weight: bold;\n        }\n\n        .action-group {\n          margin-bottom: 2rem;\n        }\n\n        .action-group h4 {\n          margin: 0 0 1rem 0;\n          color: #34495e;\n        }\n\n        .action-controls {\n          display: flex;\n          gap: 0.5rem;\n          margin-bottom: 0.5rem;\n          flex-wrap: wrap;\n        }\n\n        .action-controls input {\n          padding: 8px;\n          border: 1px solid #ddd;\n          border-radius: 4px;\n          font-size: 14px;\n        }\n\n        .action-controls input[type=\"number\"] {\n          width: 100px;\n        }\n\n        .action-controls input[type=\"text\"] {\n          flex: 1;\n          min-width: 200px;\n        }\n\n        .action-btn {\n          padding: 8px 16px;\n          border: none;\n          border-radius: 4px;\n          cursor: pointer;\n          font-size: 14px;\n          font-weight: bold;\n        }\n\n        .action-btn:disabled {\n          opacity: 0.5;\n          cursor: not-allowed;\n        }\n\n        .damage-btn {\n          background: #e74c3c;\n          color: white;\n        }\n\n        .damage-btn:hover:not(:disabled) {\n          background: #c0392b;\n        }\n\n        .vp-btn {\n          background: #f39c12;\n          color: white;\n        }\n\n        .vp-btn:hover:not(:disabled) {\n          background: #e67e22;\n        }\n\n        .next-turn-btn {\n          background: #27ae60;\n          color: white;\n          padding: 12px 24px;\n          font-size: 16px;\n        }\n\n        .next-turn-btn:hover:not(:disabled) {\n          background: #219a52;\n        }\n\n        .game-sidebar {\n          display: flex;\n          flex-direction: column;\n          gap: 2rem;\n        }\n\n        .victory-points, .recent-updates {\n          background: white;\n          padding: 1.5rem;\n          border-radius: 8px;\n          box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n        }\n\n        .victory-points h3, .recent-updates h3 {\n          margin: 0 0 1rem 0;\n          color: #2c3e50;\n        }\n\n        .vp-entry {\n          display: flex;\n          justify-content: space-between;\n          padding: 0.5rem 0;\n          border-bottom: 1px solid #eee;\n        }\n\n        .updates-list {\n          max-height: 300px;\n          overflow-y: auto;\n        }\n\n        .update-item {\n          padding: 0.75rem 0;\n          border-bottom: 1px solid #eee;\n        }\n\n        .update-type {\n          font-weight: bold;\n          color: #3498db;\n          font-size: 12px;\n          text-transform: uppercase;\n        }\n\n        .update-details {\n          color: #666;\n          font-size: 14px;\n          margin-top: 0.25rem;\n        }\n\n        .selected-unit-info {\n          background: #f8f9fa;\n          border: 1px solid #dee2e6;\n          border-radius: 6px;\n          padding: 1rem;\n          margin-top: 1rem;\n        }\n\n        .unit-header h4 {\n          margin: 0 0 0.5rem 0;\n          color: #333;\n        }\n\n        .unit-stats {\n          display: flex;\n          gap: 1rem;\n          margin-bottom: 1rem;\n          font-size: 0.9rem;\n          color: #666;\n        }\n\n        .model-groups-section h5 {\n          margin: 0 0 0.75rem 0;\n          color: #495057;\n          font-size: 1rem;\n        }\n\n        .model-group-card {\n          border: 2px solid #ddd;\n          padding: 0.75rem;\n          border-radius: 6px;\n          margin-bottom: 1rem;\n          background: white;\n          transition: all 0.3s;\n        }\n\n        .model-group-card h6 {\n          margin: 0 0 0.5rem 0;\n          color: #2c3e50;\n          font-size: 1rem;\n          font-weight: 600;\n        }\n\n        .weapon-entry {\n          margin-bottom: 0.75rem;\n        }\n\n        .weapon-name {\n          font-weight: 500;\n          color: #333;\n          display: block;\n          margin-bottom: 0.25rem;\n          font-size: 0.9rem;\n        }\n\n        .weapon-stats {\n          display: flex;\n          gap: 0.75rem;\n          flex-wrap: wrap;\n          font-size: 0.8rem;\n          color: #666;\n          margin-bottom: 0.25rem;\n        }\n\n        .weapon-abilities {\n          font-size: 0.8rem;\n          color: #666;\n          margin-top: 0.25rem;\n        }\n\n        @media (max-width: 1024px) {\n          .game-content {\n            grid-template-columns: 1fr;\n          }\n          \n          .game-sidebar {\n            order: -1;\n          }\n        }\n\n        @media (max-width: 768px) {\n          .game-info {\n            flex-direction: column;\n            gap: 0.5rem;\n          }\n          \n          .units-grid {\n            grid-template-columns: 1fr;\n          }\n          \n          .action-controls {\n            flex-direction: column;\n          }\n          \n          .action-controls input[type=\"text\"] {\n            min-width: auto;\n          }\n        }\n      `}</style>\n    </div>\n  );\n};\n\nexport default GameSession;\n",
    "usedDeprecatedRules": [
      { "ruleId": "dot-location", "replacedBy": [] },
      { "ruleId": "new-parens", "replacedBy": [] },
      { "ruleId": "no-mixed-operators", "replacedBy": [] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "no-whitespace-before-property", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\John\\Documents\\Code\\tabletop-army-manager\\src\\components\\ThemeToggle.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "dot-location", "replacedBy": [] },
      { "ruleId": "new-parens", "replacedBy": [] },
      { "ruleId": "no-mixed-operators", "replacedBy": [] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "no-whitespace-before-property", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\John\\Documents\\Code\\tabletop-army-manager\\src\\components\\UnitDatasheet.js",
    "messages": [
      {
        "ruleId": "react-hooks/rules-of-hooks",
        "severity": 2,
        "message": "React Hook \"useMemo\" is called conditionally. React Hooks must be called in the exact same order in every component render.",
        "line": 8,
        "column": 26,
        "nodeType": "Identifier",
        "endLine": 8,
        "endColumn": 33
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React, { useMemo, useState } from 'react';\r\nimport './UnitDatasheet.css';\r\n\r\nconst UnitDatasheet = ({ unit, isSelected, onClick, overrides, allUnits = [], onUpdateOverrides }) => {\r\n  if (!unit) return null;\r\n\r\n  // Group identical weapons for display (parser now expands to 1 entry per weapon instance)\r\n  const groupedWeapons = useMemo(() => {\r\n    const list = Array.isArray(unit.weapons) ? unit.weapons : [];\r\n    const map = new Map();\r\n    const keyOf = (w) => {\r\n      const name = w.name || '';\r\n      const range = (w.range === 'Melee' || w.type === 'Melee') ? 'Melee' : (w.range || '12\"');\r\n      const type = w.type || (range === 'Melee' ? 'Melee' : 'Assault 1');\r\n      const attacks = w.attacks ?? 1;\r\n      const skill = w.skill ?? 3;\r\n      const strength = w.strength ?? 4;\r\n      const ap = w.ap ?? 0;\r\n      const damage = w.damage ?? 1;\r\n      return `${name}|${range}|${type}|${attacks}|${skill}|${strength}|${ap}|${damage}`;\r\n    };\r\n    list.forEach(w => {\r\n      const k = keyOf(w);\r\n      const existing = map.get(k);\r\n      if (existing) {\r\n        existing.count = (existing.count || 1) + 1;\r\n      } else {\r\n        map.set(k, { ...w, count: w.count || 1 });\r\n      }\r\n    });\r\n    return Array.from(map.values());\r\n  }, [unit.weapons]);\r\n\r\n  // Separate grouped weapons by type\r\n  const rangedWeapons = groupedWeapons.filter(weapon => \r\n    weapon.type !== 'Melee' && weapon.range !== 'Melee'\r\n  );\r\n  \r\n  const meleeWeapons = groupedWeapons.filter(weapon => \r\n    weapon.type === 'Melee' || weapon.range === 'Melee'\r\n  );\r\n\r\n  // Get unit stats for header\r\n  const getStatValue = (stat, defaultValue = '-') => {\r\n    return stat !== undefined ? `${stat}+` : defaultValue;\r\n  };\r\n\r\n  return (\r\n    <div \r\n      className={`unit-datasheet ${isSelected ? 'selected' : ''}`}\r\n      onClick={onClick}\r\n    >\r\n      {/* Unit Header */}\r\n      <div className=\"datasheet-header\">\r\n        <div className=\"unit-title\">\r\n          <h2>{unit.name}</h2>\r\n          <div className=\"unit-size\">{unit.models} {unit.models === 1 ? 'model' : 'models'}</div>\r\n        </div>\r\n        \r\n        {/* Unit Stats */}\r\n        <div className=\"unit-stats-row\">\r\n          <div className=\"stat-box\">\r\n            <div className=\"stat-label\">M</div>\r\n            <div className=\"stat-value\">12\"</div>\r\n          </div>\r\n          <div className=\"stat-box\">\r\n            <div className=\"stat-label\">T</div>\r\n            <div className=\"stat-value\">{unit.toughness || 4}</div>\r\n          </div>\r\n          <div className=\"stat-box\">\r\n            <div className=\"stat-label\">Sv</div>\r\n            <div className=\"stat-value\">{getStatValue(unit.armor_save, '3+')}</div>\r\n          </div>\r\n          <div className=\"stat-box\">\r\n            <div className=\"stat-label\">W</div>\r\n            <div className=\"stat-value\">{unit.wounds || 1}</div>\r\n          </div>\r\n          <div className=\"stat-box\">\r\n            <div className=\"stat-label\">Ld</div>\r\n            <div className=\"stat-value\">6+</div>\r\n          </div>\r\n          <div className=\"stat-box\">\r\n            <div className=\"stat-label\">OC</div>\r\n            <div className=\"stat-value\">1</div>\r\n          </div>\r\n        </div>\r\n      </div>\r\n\r\n      <div className=\"datasheet-content\">\r\n        {/* Ranged Weapons */}\r\n        {rangedWeapons.length > 0 && (\r\n          <div className=\"weapons-section\">\r\n            <div className=\"section-header ranged-header\">\r\n              <span className=\"weapon-icon\">🎯</span>\r\n              <span>RANGED WEAPONS</span>\r\n            </div>\r\n            <div className=\"weapons-table\">\r\n              <div className=\"weapons-table-header\">\r\n                <div className=\"weapon-name-col\">WEAPON</div>\r\n                <div className=\"weapon-stat-col\">RANGE</div>\r\n                <div className=\"weapon-stat-col\">A</div>\r\n                <div className=\"weapon-stat-col\">BS</div>\r\n                <div className=\"weapon-stat-col\">S</div>\r\n                <div className=\"weapon-stat-col\">AP</div>\r\n                <div className=\"weapon-stat-col\">D</div>\r\n              </div>\r\n              {rangedWeapons.map((weapon, index) => (\r\n                <div key={index} className=\"weapon-row\">\r\n                  <div className=\"weapon-name-col\">\r\n                    <div className=\"weapon-name\">{weapon.name}</div>\r\n                    {weapon.count > 1 && <div className=\"weapon-count\">(x{weapon.count})</div>}\r\n                  </div>\r\n                  <div className=\"weapon-stat-col\">{weapon.range}</div>\r\n                  <div className=\"weapon-stat-col\">{weapon.attacks}</div>\r\n                  <div className=\"weapon-stat-col\">{getStatValue(weapon.skill, '3+')}</div>\r\n                  <div className=\"weapon-stat-col\">{weapon.strength}</div>\r\n                  <div className=\"weapon-stat-col\">{weapon.ap}</div>\r\n                  <div className=\"weapon-stat-col\">{weapon.damage}</div>\r\n                </div>\r\n              ))}\r\n            </div>\r\n          </div>\r\n        )}\r\n\r\n        {/* Melee Weapons */}\r\n        {meleeWeapons.length > 0 && (\r\n          <div className=\"weapons-section\">\r\n            <div className=\"section-header melee-header\">\r\n              <span className=\"weapon-icon\">⚔️</span>\r\n              <span>MELEE WEAPONS</span>\r\n            </div>\r\n            <div className=\"weapons-table\">\r\n              <div className=\"weapons-table-header\">\r\n                <div className=\"weapon-name-col\">WEAPON</div>\r\n                <div className=\"weapon-stat-col\">RANGE</div>\r\n                <div className=\"weapon-stat-col\">A</div>\r\n                <div className=\"weapon-stat-col\">WS</div>\r\n                <div className=\"weapon-stat-col\">S</div>\r\n                <div className=\"weapon-stat-col\">AP</div>\r\n                <div className=\"weapon-stat-col\">D</div>\r\n              </div>\r\n              {meleeWeapons.map((weapon, index) => (\r\n                <div key={index} className=\"weapon-row\">\r\n                  <div className=\"weapon-name-col\">\r\n                    <div className=\"weapon-name\">{weapon.name}</div>\r\n                    {weapon.count > 1 && <div className=\"weapon-count\">(x{weapon.count})</div>}\r\n                  </div>\r\n                  <div className=\"weapon-stat-col\">Melee</div>\r\n                  <div className=\"weapon-stat-col\">{weapon.attacks}</div>\r\n                  <div className=\"weapon-stat-col\">{getStatValue(weapon.skill, '3+')}</div>\r\n                  <div className=\"weapon-stat-col\">{weapon.strength}</div>\r\n                  <div className=\"weapon-stat-col\">{weapon.ap}</div>\r\n                  <div className=\"weapon-stat-col\">{weapon.damage}</div>\r\n                </div>\r\n              ))}\r\n            </div>\r\n          </div>\r\n        )}\r\n\r\n        <div className=\"datasheet-bottom\">\r\n          {/* Abilities */}\r\n          {unit.abilities && unit.abilities.length > 0 && (\r\n            <div className=\"abilities-section\">\r\n              <div className=\"section-header abilities-header\">ABILITIES</div>\r\n              <div className=\"abilities-content\">\r\n                {unit.abilities.map((ability, index) => (\r\n                  <div key={index} className=\"ability-item\">\r\n                    <div className=\"ability-name\">{ability.name}:</div>\r\n                    <div className=\"ability-description\">{ability.description}</div>\r\n                  </div>\r\n                ))}\r\n              </div>\r\n            </div>\r\n          )}\r\n\r\n          {/* Unit Composition */}\r\n          {unit.modelGroups && unit.modelGroups.length > 0 && (\r\n            <div className=\"composition-section\">\r\n              <div className=\"section-header composition-header\">UNIT COMPOSITION</div>\r\n              <div className=\"composition-content\">\r\n                {unit.modelGroups.map((group, index) => (\r\n                  <div key={index} className=\"composition-item\">\r\n                    • {group.count}x {group.name}\r\n                  </div>\r\n                ))}\r\n                <div className=\"points-cost\">{unit.models} models - {unit.points} pts</div>\r\n              </div>\r\n            </div>\r\n          )}\r\n\r\n          {/* Keywords */}\r\n          {unit.keywords && unit.keywords.length > 0 && (\r\n            <div className=\"keywords-section\">\r\n              <div className=\"keywords-header\">\r\n                <span className=\"keywords-label\">KEYWORDS:</span>\r\n                <span className=\"keywords-list\">\r\n                  {unit.keywords.join(', ').toUpperCase()}\r\n                </span>\r\n              </div>\r\n            </div>\r\n          )}\r\n\r\n          {/* Leadership Overrides - Compact Collapsible */}\r\n          <OverridesCollapsible\r\n            unit={unit}\r\n            overrides={overrides}\r\n            allUnits={allUnits}\r\n            onUpdateOverrides={onUpdateOverrides}\r\n          />\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nconst OverridesCollapsible = ({ unit, overrides, allUnits, onUpdateOverrides }) => {\r\n  const [open, setOpen] = useState(false);\r\n\r\n  const activeCount = useMemo(() => {\r\n    let n = 0;\r\n    if (overrides?.canLead && overrides.canLead !== 'auto') n += 1;\r\n    if (overrides?.canBeLed && overrides.canBeLed !== 'auto') n += 1;\r\n    n += (overrides?.allowList?.length || 0);\r\n    return n;\r\n  }, [overrides]);\r\n\r\n  const statusText = activeCount > 0 ? `Overridden (${activeCount})` : 'Off';\r\n  const statusClass = activeCount > 0 ? 'overridden' : 'off';\r\n\r\n  const onToggleLead = (checked) => {\r\n    onUpdateOverrides?.({ canLead: checked ? 'yes' : 'auto' });\r\n  };\r\n  const onToggleLed = (checked) => {\r\n    onUpdateOverrides?.({ canBeLed: checked ? 'yes' : 'auto' });\r\n  };\r\n\r\n  const onReset = () => {\r\n    onUpdateOverrides?.({ canLead: 'auto', canBeLed: 'auto', allowList: [] });\r\n  };\r\n\r\n  return (\r\n    <div className=\"overrides-collapsible\">\r\n      <button type=\"button\" className=\"overrides-header\" onClick={() => setOpen(!open)}>\r\n        <span className={`chevron ${open ? 'open' : ''}`}>▸</span>\r\n        <span>Override</span>\r\n        <span className={`status-chip ${statusClass}`}>{statusText}</span>\r\n      </button>\r\n      {open && (\r\n        <div className=\"overrides-panel\">\r\n          <div className=\"flags-row\" role=\"group\" aria-label=\"Override flags\">\r\n            <label className=\"flag-item\" aria-label=\"Can lead\">\r\n              <input\r\n                type=\"checkbox\"\r\n                checked={overrides?.canLead === 'yes'}\r\n                onChange={(e) => onToggleLead(e.target.checked)}\r\n              />\r\n              <span>Can lead</span>\r\n            </label>\r\n            <label className=\"flag-item\" aria-label=\"Can be led\">\r\n              <input\r\n                type=\"checkbox\"\r\n                checked={overrides?.canBeLed === 'yes'}\r\n                onChange={(e) => onToggleLed(e.target.checked)}\r\n              />\r\n              <span>Can be led</span>\r\n            </label>\r\n          </div>\r\n\r\n          <PairwiseControls\r\n            unit={unit}\r\n            allUnits={allUnits}\r\n            overrides={overrides}\r\n            onUpdateOverrides={onUpdateOverrides}\r\n          />\r\n\r\n          <div className=\"override-actions\">\r\n            <button\r\n              type=\"button\"\r\n              className=\"btn-secondary\"\r\n              onClick={onReset}\r\n            >\r\n              Reset\r\n            </button>\r\n          </div>\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n};\r\n\r\nconst PairwiseControls = ({ unit, allUnits, overrides, onUpdateOverrides }) => {\r\n  const [allowSelect, setAllowSelect] = useState('');\r\n  const unitOptions = useMemo(() => {\r\n    return allUnits.filter(u => u.id !== unit.id).map(u => ({ id: u.id, name: u.name }));\r\n  }, [allUnits, unit.id]);\r\n\r\n  const addAllow = () => {\r\n    if (!allowSelect) return;\r\n    const next = Array.from(new Set([...(overrides?.allowList || []), allowSelect]));\r\n    onUpdateOverrides?.({ allowList: next });\r\n    setAllowSelect('');\r\n  };\r\n  const removeAllow = (id) => {\r\n    const next = (overrides?.allowList || []).filter(x => x !== id);\r\n    onUpdateOverrides?.({ allowList: next });\r\n  };\r\n\r\n  return (\r\n    <div className=\"pairwise-overrides single\">\r\n      <div className=\"pair-column\" aria-label=\"Allow specific pairings\">\r\n        <label htmlFor=\"allow-search\">Allow specific pairings</label>\r\n        <div className=\"pair-add-row\">\r\n          <select aria-label=\"Select unit to allow\" value={allowSelect} onChange={(e) => setAllowSelect(e.target.value)}>\r\n            <option value=\"\">Select a unit…</option>\r\n            {(unitOptions || []).map(opt => (\r\n              <option key={opt.id} value={opt.id}>{opt.name}</option>\r\n            ))}\r\n          </select>\r\n          <button type=\"button\" className=\"btn-primary\" onClick={addAllow}>Add</button>\r\n        </div>\r\n        <div className=\"chips\" aria-label=\"Allowed list\">\r\n          {(overrides?.allowList || []).map(id => {\r\n            const u = allUnits.find(x => x.id === id);\r\n            return (\r\n              <span key={id} className=\"chip\">\r\n                {u ? u.name : id}\r\n                <button type=\"button\" aria-label={`Remove ${u ? u.name : id} from allow list`} onClick={() => removeAllow(id)}>×</button>\r\n              </span>\r\n            );\r\n          })}\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default UnitDatasheet;\r\n",
    "usedDeprecatedRules": [
      { "ruleId": "dot-location", "replacedBy": [] },
      { "ruleId": "new-parens", "replacedBy": [] },
      { "ruleId": "no-mixed-operators", "replacedBy": [] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "no-whitespace-before-property", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\John\\Documents\\Code\\tabletop-army-manager\\src\\components\\__tests__\\UnitOverrides.test.jsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "dot-location", "replacedBy": [] },
      { "ruleId": "new-parens", "replacedBy": [] },
      { "ruleId": "no-mixed-operators", "replacedBy": [] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "no-whitespace-before-property", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\John\\Documents\\Code\\tabletop-army-manager\\src\\contexts\\ThemeContext.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "dot-location", "replacedBy": [] },
      { "ruleId": "new-parens", "replacedBy": [] },
      { "ruleId": "no-mixed-operators", "replacedBy": [] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "no-whitespace-before-property", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\John\\Documents\\Code\\tabletop-army-manager\\src\\firebase\\auth.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "dot-location", "replacedBy": [] },
      { "ruleId": "new-parens", "replacedBy": [] },
      { "ruleId": "no-mixed-operators", "replacedBy": [] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "no-whitespace-before-property", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\John\\Documents\\Code\\tabletop-army-manager\\src\\firebase\\config.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "dot-location", "replacedBy": [] },
      { "ruleId": "new-parens", "replacedBy": [] },
      { "ruleId": "no-mixed-operators", "replacedBy": [] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "no-whitespace-before-property", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\John\\Documents\\Code\\tabletop-army-manager\\src\\firebase\\database.js",
    "messages": [
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'arrayRemove' is defined but never used.",
        "line": 15,
        "column": 3,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 15,
        "endColumn": 14
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { \n  collection, \n  doc, \n  addDoc, \n  updateDoc, \n  deleteDoc, \n  getDoc, \n  getDocs, \n  query, \n  where, \n  orderBy, \n  onSnapshot,\n  serverTimestamp,\n  arrayUnion,\n  arrayRemove\n} from 'firebase/firestore';\nimport { db } from './config';\n\n// Database structure based on your existing army manager requirements\nexport const DATABASE_COLLECTIONS = {\n  USERS: 'users',\n  ARMIES: 'armies',\n  GAMES: 'games',\n  ARMY_TEMPLATES: 'armyTemplates'\n};\n\n// User Management\nexport const createUser = async (userId, userData) => {\n  const userRef = doc(db, DATABASE_COLLECTIONS.USERS, userId);\n  await updateDoc(userRef, {\n    ...userData,\n    createdAt: serverTimestamp(),\n    lastActive: serverTimestamp()\n  });\n};\n\nexport const getUser = async (userId) => {\n  const userRef = doc(db, DATABASE_COLLECTIONS.USERS, userId);\n  const userSnap = await getDoc(userRef);\n  return userSnap.exists() ? { id: userSnap.id, ...userSnap.data() } : null;\n};\n\n// Army Management\nexport const createArmy = async (userId, armyData) => {\n  const armyRef = await addDoc(collection(db, DATABASE_COLLECTIONS.ARMIES), {\n    ...armyData,\n    ownerId: userId,\n    createdAt: serverTimestamp(),\n    updatedAt: serverTimestamp()\n  });\n  return armyRef.id;\n};\n\n// Get user's games\nexport const getUserGames = async (userId) => {\n  try {\n    const gamesRef = collection(db, DATABASE_COLLECTIONS.GAMES);\n    const q = query(gamesRef, where('players', 'array-contains', userId));\n    const querySnapshot = await getDocs(q);\n    \n    const games = [];\n    querySnapshot.forEach((doc) => {\n      games.push({\n        id: doc.id,\n        ...doc.data()\n      });\n    });\n    \n    return games;\n  } catch (error) {\n    console.error('Error getting games:', error);\n    throw error;\n  }\n};\n\nexport const getUserArmies = async (userId) => {\n  try {\n    const armiesRef = collection(db, DATABASE_COLLECTIONS.ARMIES);\n    const q = query(armiesRef, where('ownerId', '==', userId));\n    const querySnapshot = await getDocs(q);\n    \n    const armies = [];\n    querySnapshot.forEach((doc) => {\n      armies.push({\n        id: doc.id,\n        ...doc.data()\n      });\n    });\n    \n    return armies;\n  } catch (error) {\n    console.error('Error getting armies:', error);\n    throw error;\n  }\n};\n\nexport const updateArmy = async (armyId, updates) => {\n  const armyRef = doc(db, DATABASE_COLLECTIONS.ARMIES, armyId);\n  await updateDoc(armyRef, {\n    ...updates,\n    updatedAt: serverTimestamp()\n  });\n};\n\nexport const deleteArmy = async (armyId) => {\n  const armyRef = doc(db, DATABASE_COLLECTIONS.ARMIES, armyId);\n  await deleteDoc(armyRef);\n};\n\n// Game Session Management\nexport const createGame = async (gameData) => {\n  const gameRef = await addDoc(collection(db, DATABASE_COLLECTIONS.GAMES), {\n    ...gameData,\n    status: 'waiting', // waiting, active, completed\n    createdAt: serverTimestamp(),\n    updatedAt: serverTimestamp(),\n    currentTurn: 0,\n    round: 1\n  });\n  return gameRef.id;\n};\n\nexport const joinGame = async (gameId, userId, playerName, armyData = null) => {\n  const gameRef = doc(db, DATABASE_COLLECTIONS.GAMES, gameId);\n  const updateData = {\n    players: arrayUnion(userId),\n    updatedAt: serverTimestamp()\n  };\n  \n  // If army data is provided, add it to playerArmies\n  if (armyData) {\n    updateData[`playerArmies.${userId}`] = {\n      playerName: playerName,\n      armyData: armyData\n    };\n  } else {\n    // Just add the player name for now\n    updateData[`playerArmies.${userId}`] = {\n      playerName: playerName,\n      armyData: null\n    };\n  }\n  \n  await updateDoc(gameRef, updateData);\n};\n\nexport const updateGameState = async (gameId, updates) => {\n  const gameRef = doc(db, DATABASE_COLLECTIONS.GAMES, gameId);\n  await updateDoc(gameRef, {\n    ...updates,\n    updatedAt: serverTimestamp()\n  });\n};\n\nexport const deleteGame = async (gameId) => {\n  const gameRef = doc(db, DATABASE_COLLECTIONS.GAMES, gameId);\n  await deleteDoc(gameRef);\n};\n\n// Real-time game updates\nexport const subscribeToGame = (gameId, callback) => {\n  const gameRef = doc(db, DATABASE_COLLECTIONS.GAMES, gameId);\n  return onSnapshot(gameRef, (doc) => {\n    if (doc.exists()) {\n      callback({ id: doc.id, ...doc.data() });\n    }\n  });\n};\n\n// Combat and Damage Tracking\nexport const assignDamage = async (gameId, targetUnitId, damage, attackerId = null) => {\n  const gameRef = doc(db, DATABASE_COLLECTIONS.GAMES, gameId);\n  const updateData = {\n    [`gameState.units.${targetUnitId}.currentWounds`]: damage.remainingWounds,\n    [`gameState.units.${targetUnitId}.totalDamage`]: damage.totalDamage,\n    updatedAt: serverTimestamp()\n  };\n\n  // Add to damage history\n  const damageRecord = {\n    id: `damage_${Date.now()}`,\n    targetUnitId,\n    attackerId,\n    damage: damage.damageDealt,\n    timestamp: serverTimestamp(),\n    type: 'damage'\n  };\n\n  updateData[`gameState.damageHistory.${damageRecord.id}`] = damageRecord;\n\n  await updateDoc(gameRef, updateData);\n  \n  // Add real-time update\n  await addGameUpdate(gameId, {\n    type: 'damage',\n    targetUnitId,\n    attackerId,\n    damage: damage.damageDealt,\n    playerId: attackerId\n  });\n};\n\n// Victory Points Management\nexport const assignVictoryPoints = async (gameId, playerId, points, reason) => {\n  const gameRef = doc(db, DATABASE_COLLECTIONS.GAMES, gameId);\n  const vpRecord = {\n    id: `vp_${Date.now()}`,\n    playerId,\n    points,\n    reason,\n    timestamp: serverTimestamp(),\n    type: 'victory_points'\n  };\n\n  await updateDoc(gameRef, {\n    [`gameState.victoryPoints.${playerId}`]: arrayUnion(vpRecord),\n    [`gameState.totalVP.${playerId}`]: (await getGameVP(gameId, playerId)) + points,\n    updatedAt: serverTimestamp()\n  });\n\n  await addGameUpdate(gameId, {\n    type: 'victory_points',\n    playerId,\n    points,\n    reason\n  });\n};\n\n// Turn Management\nexport const nextTurn = async (gameId) => {\n  const gameRef = doc(db, DATABASE_COLLECTIONS.GAMES, gameId);\n  const gameSnap = await getDoc(gameRef);\n  \n  if (gameSnap.exists()) {\n    const gameData = gameSnap.data();\n    const nextTurnIndex = (gameData.currentTurn + 1) % gameData.players.length;\n    const nextRound = nextTurnIndex === 0 ? gameData.round + 1 : gameData.round;\n    \n    await updateDoc(gameRef, {\n      currentTurn: nextTurnIndex,\n      round: nextRound,\n      updatedAt: serverTimestamp()\n    });\n\n    await addGameUpdate(gameId, {\n      type: 'turn_change',\n      currentPlayer: gameData.players[nextTurnIndex],\n      round: nextRound\n    });\n  }\n};\n\n// Real-time updates subcollection\nexport const addGameUpdate = async (gameId, updateData) => {\n  const updatesRef = collection(db, DATABASE_COLLECTIONS.GAMES, gameId, 'updates');\n  await addDoc(updatesRef, {\n    ...updateData,\n    timestamp: serverTimestamp()\n  });\n};\n\nexport const subscribeToGameUpdates = (gameId, callback) => {\n  const updatesRef = collection(db, DATABASE_COLLECTIONS.GAMES, gameId, 'updates');\n  const q = query(updatesRef, orderBy('timestamp', 'desc'));\n  \n  return onSnapshot(q, (snapshot) => {\n    const updates = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));\n    callback(updates);\n  });\n};\n\n// Helper functions\nconst getGameVP = async (gameId, playerId) => {\n  const gameRef = doc(db, DATABASE_COLLECTIONS.GAMES, gameId);\n  const gameSnap = await getDoc(gameRef);\n  \n  if (gameSnap.exists()) {\n    const gameData = gameSnap.data();\n    return gameData.gameState?.totalVP?.[playerId] || 0;\n  }\n  return 0;\n};\n\n// Army Templates (for sharing armies)\nexport const createArmyTemplate = async (userId, armyData, isPublic = false) => {\n  const templateRef = await addDoc(collection(db, DATABASE_COLLECTIONS.ARMY_TEMPLATES), {\n    ...armyData,\n    createdBy: userId,\n    isPublic,\n    createdAt: serverTimestamp(),\n    downloads: 0\n  });\n  return templateRef.id;\n};\n\nexport const getPublicArmyTemplates = async () => {\n  const q = query(\n    collection(db, DATABASE_COLLECTIONS.ARMY_TEMPLATES),\n    where('isPublic', '==', true),\n    orderBy('downloads', 'desc')\n  );\n  const querySnapshot = await getDocs(q);\n  return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));\n};\n",
    "usedDeprecatedRules": [
      { "ruleId": "dot-location", "replacedBy": [] },
      { "ruleId": "new-parens", "replacedBy": [] },
      { "ruleId": "no-mixed-operators", "replacedBy": [] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "no-whitespace-before-property", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\John\\Documents\\Code\\tabletop-army-manager\\src\\index.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "dot-location", "replacedBy": [] },
      { "ruleId": "new-parens", "replacedBy": [] },
      { "ruleId": "no-mixed-operators", "replacedBy": [] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "no-whitespace-before-property", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\John\\Documents\\Code\\tabletop-army-manager\\src\\setupTests.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "dot-location", "replacedBy": [] },
      { "ruleId": "new-parens", "replacedBy": [] },
      { "ruleId": "no-mixed-operators", "replacedBy": [] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "no-whitespace-before-property", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\John\\Documents\\Code\\tabletop-army-manager\\src\\utils\\armyParser.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "dot-location", "replacedBy": [] },
      { "ruleId": "new-parens", "replacedBy": [] },
      { "ruleId": "no-mixed-operators", "replacedBy": [] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "no-whitespace-before-property", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\John\\Documents\\Code\\tabletop-army-manager\\src\\utils\\armyParser.old.js",
    "messages": [
      {
        "ruleId": "default-case",
        "severity": 1,
        "message": "Expected a default case.",
        "line": 119,
        "column": 23,
        "nodeType": "SwitchStatement",
        "messageId": "missingDefaultCase",
        "endLine": 153,
        "endColumn": 24
      },
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'extractUnitData' is assigned a value but never used.",
        "line": 281,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 281,
        "endColumn": 24
      },
      {
        "ruleId": "default-case",
        "severity": 1,
        "message": "Expected a default case.",
        "line": 404,
        "column": 25,
        "nodeType": "SwitchStatement",
        "messageId": "missingDefaultCase",
        "endLine": 444,
        "endColumn": 26
      },
      {
        "ruleId": "default-case",
        "severity": 1,
        "message": "Expected a default case.",
        "line": 487,
        "column": 19,
        "nodeType": "SwitchStatement",
        "messageId": "missingDefaultCase",
        "endLine": 526,
        "endColumn": 20
      },
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'convertBattleScribeWeapon' is assigned a value but never used.",
        "line": 644,
        "column": 7,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 644,
        "endColumn": 32
      },
      {
        "ruleId": "default-case",
        "severity": 1,
        "message": "Expected a default case.",
        "line": 659,
        "column": 5,
        "nodeType": "SwitchStatement",
        "messageId": "missingDefaultCase",
        "endLine": 685,
        "endColumn": 6
      },
      {
        "ruleId": "no-unused-vars",
        "severity": 1,
        "message": "'generateId' is assigned a value but never used.",
        "line": 732,
        "column": 7,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 732,
        "endColumn": 17
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 7,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "// Army parser utility to handle both BattleScribe and simple JSON formats\n// Based on the existing Python converter logic\n\nexport const parseArmyFile = (jsonData) => {\n  // Auto-detect BattleScribe format (has 'roster' key)\n  if (jsonData.roster) {\n    return convertBattleScribeToSimple(jsonData);\n  }\n  \n  // Already in simple format, validate and return\n  return validateSimpleFormat(jsonData);\n};\n\nconst convertBattleScribeToSimple = (battleScribeData) => {\n  const roster = battleScribeData.roster;\n  const forces = roster.forces || [];\n  \n  if (forces.length === 0) {\n    throw new Error('No forces found in BattleScribe roster');\n  }\n  \n  const force = forces[0]; // Use first force\n  const selections = force.selections || [];\n  \n  // Extract army name from force or use default\n  const armyName = force.name || 'Imported Army';\n  \n  // Extract faction from force rules or categories\n  let faction = 'Unknown';\n  if (force.rules && force.rules.length > 0) {\n    faction = force.rules[0].name || 'Unknown';\n  }\n  \n  const units = [];\n  \n  // Process selections to extract units\n  selections.forEach(selection => {\n    if (selection.type === 'model' || selection.type === 'unit') {\n      const unit = convertBattleScribeUnit(selection);\n      if (unit) {\n        units.push(unit);\n      }\n    }\n  });\n  \n  return {\n    name: armyName,\n    faction: faction,\n    units: units\n  };\n};\n\nconst convertBattleScribeUnit = (selection) => {\n  const unit = {\n    name: selection.name || 'Unknown Unit',\n    type: 'INFANTRY',\n    models: 0,\n    wounds: 1,\n    currentWounds: 1,\n    points: 0,\n    weapons: [],\n    modelGroups: [],\n    abilities: [],\n    rules: [],\n    keywords: []\n  };\n  \n  // Scoped debug logger; enable by setting process.env.DEBUG_ARMY_PARSER = '1'\n  const dbg = (...args) => {\n    try {\n      if (typeof process !== 'undefined' && process.env && process.env.DEBUG_ARMY_PARSER === '1') {\n        console.log(...args);\n      }\n    } catch (_) {\n      // ignore if process/env not available\n    }\n  };\n  \n  // Generic scalable approach: analyze BattleScribe structure to detect model groups\n  dbg(`\\n=== ANALYZING UNIT STRUCTURE: ${unit.name} ===`);\n  \n  // Look for nested model selections in BattleScribe data\n  const detectedModelGroups = [];\n  let totalModelsDetected = 0;\n  \n  if (selection.selections) {\n    selection.selections.forEach(sel => {\n      if (sel.type === 'model' && sel.number && sel.name) {\n        dbg(`Found model group: ${sel.name} (count: ${sel.number})`);\n        \n        // Collect weapons for this model group\n        const modelGroupWeapons = [];\n        const collectModelWeapons = (selections) => {\n          if (!selections) return;\n          selections.forEach(weaponSel => {\n            if (weaponSel.profiles) {\n              weaponSel.profiles.forEach(profile => {\n                if (profile.typeName === 'Ranged Weapons' || profile.typeName === 'Melee Weapons') {\n                  const weaponCount = weaponSel.number || 1;\n                  \n                  // Create weapon object\n                  const weapon = {\n                    name: profile.name,\n                    range: '',\n                    type: profile.typeName === 'Melee Weapons' ? 'Melee' : 'Assault 1',\n                    attacks: 1,\n                    skill: 4,\n                    strength: 4,\n                    ap: 0,\n                    damage: 1,\n                    abilities: [],\n                    count: weaponCount\n                  };\n                  \n                  // Extract characteristics\n                  if (profile.characteristics) {\n                    profile.characteristics.forEach(char => {\n                      const val = char.$text;\n                      switch (char.name) {\n                        case 'Range':\n                          weapon.range = val || weapon.range;\n                          break;\n                        case 'Type':\n                          weapon.type = val || weapon.type;\n                          break;\n                        case 'A': {\n                          const n = parseInt(val, 10);\n                          weapon.attacks = isFinite(n) ? n : (val || weapon.attacks);\n                          break;\n                        }\n                        case 'WS':\n                        case 'BS': {\n                          const m = typeof val === 'string' ? val.match(/(\\d+)/) : null;\n                          const n = m ? parseInt(m[1], 10) : NaN;\n                          weapon.skill = isFinite(n) ? n : weapon.skill;\n                          break;\n                        }\n                        case 'S': {\n                          const n = parseInt(val, 10);\n                          weapon.strength = isFinite(n) ? n : weapon.strength;\n                          break;\n                        }\n                        case 'AP': {\n                          const n = parseInt(val, 10);\n                          weapon.ap = isFinite(n) ? n : weapon.ap;\n                          break;\n                        }\n                        case 'D': {\n                          const n = parseInt(val, 10);\n                          weapon.damage = isFinite(n) ? n : weapon.damage;\n                          break;\n                        }\n                      }\n                    });\n                  }\n                  \n                  modelGroupWeapons.push(weapon);\n                  dbg(`  Added weapon: ${weapon.name} (x${weapon.count})`);\n                }\n              });\n            }\n            if (weaponSel.selections) {\n              collectModelWeapons(weaponSel.selections);\n            }\n          });\n        };\n        \n        collectModelWeapons(sel.selections);\n        \n        // Create model group\n        detectedModelGroups.push({\n          name: sel.name,\n          count: sel.number,\n          weapons: modelGroupWeapons\n        });\n        \n        totalModelsDetected += sel.number;\n      }\n    });\n  }\n  \n  // If we found model groups, use them\n  if (detectedModelGroups.length > 0) {\n    dbg(`✅ Found ${detectedModelGroups.length} model groups, total models: ${totalModelsDetected}`);\n    \n    unit.models = totalModelsDetected;\n    unit.modelGroups = detectedModelGroups;\n    \n    // Create flattened weapons array for backward compatibility\n    unit.weapons = [];\n    detectedModelGroups.forEach(group => {\n      unit.weapons.push(...group.weapons);\n    });\n    \n    dbg(`\\n--- DETECTED MODEL GROUPS ---`);\n    detectedModelGroups.forEach((group, i) => {\n      dbg(`Group ${i + 1}: ${group.count}x ${group.name}`);\n      dbg(`  Weapons: ${group.weapons.length}`);\n      group.weapons.forEach(weapon => {\n        dbg(`    - ${weapon.name} (x${weapon.count})`);\n      });\n    });\n    dbg(`=== END STRUCTURE ANALYSIS ===\\n`);\n    \n    // Extract abilities, rules, and keywords before returning (inline)\n    console.log(`🔍 ALWAYS VISIBLE: Starting extraction for ${unit.name} (model groups path)`);\n    \n    // Simple inline extraction without separate function\n    const extractInline = (sel, depth = 0) => {\n      const indent = '  '.repeat(depth);\n      console.log(`${indent}🔍 Extracting from: ${sel.name || 'unnamed'} (type: ${sel.type})`);\n      \n      if (sel.profiles) {\n        console.log(`${indent}  Found ${sel.profiles.length} profiles`);\n        sel.profiles.forEach((profile, i) => {\n          console.log(`${indent}    Profile ${i}: ${profile.name} (type: ${profile.typeName})`);\n          \n          if (profile.typeName === 'Abilities') {\n            const description = profile.characteristics && profile.characteristics.find(char => char.name === 'Description');\n            const abilityData = {\n              name: profile.name,\n              description: description ? description.$text : ''\n            };\n            console.log(`${indent}    Adding ability: ${abilityData.name}`);\n            unit.abilities.push(abilityData);\n          }\n        });\n      }\n      \n      if (sel.rules) {\n        console.log(`${indent}  Found ${sel.rules.length} rules`);\n        sel.rules.forEach(rule => {\n          if (rule.name) {\n            console.log(`${indent}    Adding rule: ${rule.name}`);\n            unit.rules.push(rule.name);\n          }\n        });\n      }\n      \n      if (sel.selections) {\n        console.log(`${indent}  Recursing into ${sel.selections.length} nested selections`);\n        sel.selections.forEach(nestedSel => {\n          extractInline(nestedSel, depth + 1);\n        });\n      }\n    };\n    \n    extractInline(selection);\n    \n    console.log(`🔍 ALWAYS VISIBLE: Final data for ${unit.name}:`, {\n      abilities: unit.abilities.length,\n      rules: unit.rules.length, \n      keywords: unit.keywords.length\n    });\n    \n    return unit;\n  } else {\n    dbg(`❌ No model groups detected, falling back to original parsing`);\n  }\n  \n  // Extract points cost\n  if (selection.costs) {\n    const pointsCost = selection.costs.find(cost => cost.name === 'pts');\n    if (pointsCost) {\n      unit.points = pointsCost.value || 0;\n    }\n  }\n  \n  // If the selection itself is a model, set the model count\n  if (selection.type === 'model' || selection.type === 'unit') {\n    unit.models = selection.number || 1;\n  }\n  \n  // Track model groups separately to maintain sergeant/standard separation\n  const modelGroups = [];\n  const weapons = unit.weapons; // Reference to the unit's weapons array for fallback\n\n  // Arrays already initialized in unit object\n\n  // Define extraction function FIRST\n  const extractUnitData = (sel, depth = 0) => {\n    const indent = '  '.repeat(depth);\n    console.log(`${indent}🔍 Extracting from: ${sel.name || 'unnamed'} (type: ${sel.type})`);\n    \n    // Debug: log what we find\n    if (sel.profiles) {\n      console.log(`${indent}  Found ${sel.profiles.length} profiles`);\n      sel.profiles.forEach((profile, i) => {\n        console.log(`${indent}    Profile ${i}: ${profile.name} (type: ${profile.typeName})`);\n      });\n    }\n    if (sel.rules) {\n      console.log(`${indent}  Found ${sel.rules.length} rules`);\n      sel.rules.forEach((rule, i) => {\n        console.log(`${indent}    Rule ${i}: ${rule.name}`);\n      });\n    }\n    \n    // Extract from profiles\n    if (sel.profiles) {\n      sel.profiles.forEach(profile => {\n        console.log(`${indent}  Processing profile: ${profile.name} (${profile.typeName})`);\n        \n        if (profile.typeName === 'Unit') {\n          if (profile.characteristics) {\n            profile.characteristics.forEach(char => {\n              const val = char.$text;\n              console.log(`${indent}    Unit characteristic: ${char.name} = ${val}`);\n              if (char.name === 'Keywords' && val && val !== '-') {\n                const keywords = val.split(',').map(k => k.trim()).filter(k => k);\n                console.log(`${indent}      Adding keywords: ${keywords.join(', ')}`);\n                unit.keywords.push(...keywords);\n              }\n            });\n          }\n        } else if (profile.typeName === 'Abilities') {\n          // Extract abilities with full descriptions\n          const description = profile.characteristics && profile.characteristics.find(char => char.name === 'Description');\n          const abilityData = {\n            name: profile.name,\n            description: description ? description.$text : ''\n          };\n          console.log(`${indent}    Adding ability: ${abilityData.name}`);\n          unit.abilities.push(abilityData);\n        }\n      });\n    }\n\n    // Extract rules from rules array\n    if (sel.rules) {\n      sel.rules.forEach(rule => {\n        if (rule.name) {\n          console.log(`${indent}    Adding rule: ${rule.name}`);\n          unit.rules.push(rule.name);\n        }\n      });\n    }\n\n    // Recursively check nested selections\n    if (sel.selections) {\n      console.log(`${indent}  Recursing into ${sel.selections.length} nested selections`);\n      sel.selections.forEach(nestedSel => {\n        extractUnitData(nestedSel, depth + 1);\n      });\n    }\n  };\n\n  // Recursively extract weapons from all nested selections and count models\n  const extractWeaponsFromSelections = (selections, depth = 0) => {\n    if (!selections) return;\n    \n    const indent = '  '.repeat(depth);\n    dbg(`${indent}Processing ${selections.length} selections at depth ${depth}`);\n    \n    selections.forEach((selection, index) => {\n      dbg(`${indent}Selection ${index}: type=\"${selection.type}\", name=\"${selection.name}\", number=${selection.number}`);\n      \n      // Check if this is a model selection to count models\n      // We only add if it's a nested model group, to avoid double-counting the top-level unit\n      if (depth > 0 && selection.type === 'model' && selection.number) {\n        dbg(`${indent}  -> Adding ${selection.number} models to unit`);\n        unit.models += selection.number;\n        \n        // Create a separate model group for this selection\n        const modelGroup = {\n          name: selection.name,\n          count: selection.number,\n          weapons: []\n        };\n        \n        // Extract weapons from this model's nested selections\n        if (selection.selections) {\n          dbg(`${indent}  -> Processing ${selection.selections.length} weapon selections for this model group`);\n          selection.selections.forEach((weaponSelection, weaponIndex) => {\n            dbg(`${indent}    Weapon selection ${weaponIndex}: type=\"${weaponSelection.type}\", name=\"${weaponSelection.name}\", number=${weaponSelection.number}`);\n            \n            if (weaponSelection.profiles) {\n              weaponSelection.profiles.forEach((profile, profileIndex) => {\n                dbg(`${indent}      Profile ${profileIndex}: typeName=\"${profile.typeName}\", name=\"${profile.name}\"`);\n                \n                if (profile.typeName === 'Ranged Weapons' || profile.typeName === 'Melee Weapons') {\n                  // In BattleScribe, the weapon selection number IS the total count for this model group\n                  const totalWeapons = weaponSelection.number || 1;\n                  \n                  dbg(`${indent}        -> Creating ${totalWeapons} instances of weapon: ${profile.name}`);\n                  \n                  for (let i = 0; i < totalWeapons; i++) {\n                    const weapon = {\n                      name: profile.name,\n                      range: '12\"',\n                      type: profile.typeName === 'Melee Weapons' ? 'Melee' : 'Assault 1',\n                      attacks: 1,\n                      skill: 4,\n                      strength: 4,\n                      ap: 0,\n                      damage: 1,\n                      abilities: []\n                    };\n                    \n                    // Extract weapon characteristics\n                    if (profile.characteristics) {\n                      profile.characteristics.forEach(char => {\n                        const val = char.$text;\n                        switch (char.name) {\n                          case 'Range':\n                            weapon.range = val || weapon.range;\n                            break;\n                          case 'Type':\n                            weapon.type = val || weapon.type;\n                            break;\n                          case 'A': {\n                            const n = parseInt(val, 10);\n                            weapon.attacks = isFinite(n) ? n : (val || weapon.attacks);\n                            break;\n                          }\n                          case 'WS':\n                          case 'BS': {\n                            // Expect like '3+' -> 3\n                            const m = typeof val === 'string' ? val.match(/(\\d+)/) : null;\n                            const n = m ? parseInt(m[1], 10) : NaN;\n                            weapon.skill = isFinite(n) ? n : weapon.skill;\n                            break;\n                          }\n                          case 'S': {\n                            const n = parseInt(val, 10);\n                            weapon.strength = isFinite(n) ? n : weapon.strength;\n                            break;\n                          }\n                          case 'AP': {\n                            const n = parseInt(val, 10);\n                            weapon.ap = isFinite(n) ? n : weapon.ap;\n                            break;\n                          }\n                          case 'D': {\n                            const n = parseInt(val, 10);\n                            weapon.damage = isFinite(n) ? n : weapon.damage;\n                            break;\n                          }\n                          case 'Keywords':\n                            if (val && val !== '-') {\n                              weapon.abilities = val.split(',').map(a => a.trim());\n                            }\n                            break;\n                        }\n                      });\n                    }\n                    \n                    modelGroup.weapons.push(weapon);\n                  }\n                }\n              });\n            }\n          });\n        }\n        \n        // Add this model group to the list\n        modelGroups.push(modelGroup);\n        \n        // IMPORTANT: Do not recurse into this model's selections again, we've already processed its weapons\n        dbg(`${indent}  -> Skipping recursion into model's selections to avoid double-counting`);\n        return; // Continue to next selection\n      }\n\n      // Process any selection that has weapon profiles (upgrade selections or direct weapon selections)\n      if (selection.profiles && selection.type !== 'model') {\n        const count = selection.number || 1;\n        dbg(`${indent}  -> Found selection with profiles, type=\"${selection.type}\", processing ${selection.profiles.length} profiles`);\n        selection.profiles.forEach((profile, profileIndex) => {\n          dbg(`${indent}    Profile ${profileIndex}: typeName=\"${profile.typeName}\", name=\"${profile.name}\", count=${count}`);\n          if (profile.typeName === 'Ranged Weapons' || profile.typeName === 'Melee Weapons') {\n            dbg(`${indent}      -> Creating ${count} weapons of type: ${profile.name}`);\n            for (let i = 0; i < count; i++) {\n              const weapon = {\n                name: profile.name,\n                range: '12\"',\n                type: profile.typeName === 'Melee Weapons' ? 'Melee' : 'Assault 1',\n                attacks: 1,\n                skill: 4,\n                strength: 4,\n                ap: 0,\n                damage: 1,\n                abilities: []\n              };\n              if (profile.characteristics) {\n                profile.characteristics.forEach(char => {\n                  const val = char.$text;\n                  switch (char.name) {\n                    case 'Range':\n                      weapon.range = val || weapon.range;\n                      break;\n                    case 'Type':\n                      weapon.type = val || weapon.type;\n                      break;\n                    case 'A': {\n                      const n = parseInt(val, 10);\n                      weapon.attacks = isFinite(n) ? n : (val || weapon.attacks);\n                      break;\n                    }\n                    case 'WS':\n                    case 'BS': {\n                      const m = typeof val === 'string' ? val.match(/(\\d+)/) : null;\n                      const n = m ? parseInt(m[1], 10) : NaN;\n                      weapon.skill = isFinite(n) ? n : weapon.skill;\n                      break;\n                    }\n                    case 'S': {\n                      const n = parseInt(val, 10);\n                      weapon.strength = isFinite(n) ? n : weapon.strength;\n                      break;\n                    }\n                    case 'AP': {\n                      const n = parseInt(val, 10);\n                      weapon.ap = isFinite(n) ? n : weapon.ap;\n                      break;\n                    }\n                    case 'D': {\n                      const n = parseInt(val, 10);\n                      weapon.damage = isFinite(n) ? n : weapon.damage;\n                      break;\n                    }\n                    case 'Keywords':\n                      if (val && val !== '-') {\n                        weapon.abilities = val.split(',').map(a => a.trim());\n                      }\n                      break;\n                  }\n                });\n              }\n              weapons.push(weapon);\n            }\n          }\n        });\n      }\n\n      // Recursively check nested selections for non-model nodes\n      if (selection.selections) {\n        dbg(`${indent}  -> Recursively processing ${selection.selections.length} nested selections`);\n        extractWeaponsFromSelections(selection.selections, depth + 1);\n      }\n    });\n  };\n  \n  dbg(`\\n=== Starting weapon extraction for unit: ${unit.name} ===`);\n  if (selection.selections) {\n    extractWeaponsFromSelections(selection.selections);\n  }\n  \n  dbg(`\\n=== Final results for unit: ${unit.name} ===`);\n  dbg(`Total models: ${unit.models}`);\n  dbg(`Total weapons: ${weapons.length}`);\n  \n  // Group weapons by name for summary\n  const weaponSummary = {};\n  weapons.forEach(weapon => {\n    weaponSummary[weapon.name] = (weaponSummary[weapon.name] || 0) + 1;\n  });\n  \n  dbg('Weapon summary:');\n  Object.entries(weaponSummary).forEach(([name, count]) => {\n    dbg(`  ${name}: ${count}`);\n  });\n  dbg('=== End weapon extraction ===\\n');\n  \n  // If we have model groups, use them; otherwise fall back to the old weapons array\n  if (modelGroups.length > 0) {\n    // Group identical weapons within each model group\n    modelGroups.forEach(modelGroup => {\n      const groupedWeapons = [];\n      const weaponMap = new Map();\n      \n      modelGroup.weapons.forEach(weapon => {\n        const key = `${weapon.name}|${weapon.range}|${weapon.type}|${weapon.attacks}|${weapon.skill}|${weapon.strength}|${weapon.ap}|${weapon.damage}`;\n        \n        if (weaponMap.has(key)) {\n          weaponMap.get(key).count++;\n        } else {\n          const groupedWeapon = { ...weapon, count: 1 };\n          weaponMap.set(key, groupedWeapon);\n          groupedWeapons.push(groupedWeapon);\n        }\n      });\n      \n      modelGroup.weapons = groupedWeapons;\n    });\n    \n    // Store model groups in the unit\n    unit.modelGroups = modelGroups;\n    \n    // Also create a flattened weapons array for backward compatibility\n    unit.weapons = [];\n    modelGroups.forEach(group => {\n      unit.weapons.push(...group.weapons);\n    });\n    \n    dbg(`Model groups: ${modelGroups.length}`);\n    modelGroups.forEach(group => {\n      dbg(`  ${group.count}x ${group.name}: ${group.weapons.length} weapon types`);\n      group.weapons.forEach(weapon => {\n        dbg(`    ${weapon.name} (x${weapon.count})`);\n      });\n    });\n  } else {\n    // Fallback: group weapons in the main weapons array\n    const groupedWeapons = [];\n    const weaponMap = new Map();\n    \n    weapons.forEach(weapon => {\n      const key = `${weapon.name}|${weapon.range}|${weapon.type}|${weapon.attacks}|${weapon.skill}|${weapon.strength}|${weapon.ap}|${weapon.damage}`;\n      \n      if (weaponMap.has(key)) {\n        weaponMap.get(key).count++;\n      } else {\n        const groupedWeapon = { ...weapon, count: 1 };\n        weaponMap.set(key, groupedWeapon);\n        groupedWeapons.push(groupedWeapon);\n      }\n    });\n    \n    unit.weapons = groupedWeapons;\n    \n    dbg(`Grouped weapons: ${groupedWeapons.length} unique weapon types`);\n    groupedWeapons.forEach(weapon => {\n      dbg(`  ${weapon.name} (x${weapon.count})`);\n    });\n  }\n  \n  dbg(`\\n=== FINAL UNIT DATA: ${unit.name} ===`);\n  dbg(`  Abilities: ${unit.abilities.length}`);\n  unit.abilities.forEach(ability => {\n    dbg(`    - ${ability.name}: ${ability.description ? ability.description.substring(0, 50) + '...' : 'No description'}`);\n  });\n  dbg(`  Rules: ${unit.rules.length}`);\n  unit.rules.forEach(rule => {\n    dbg(`    - ${rule}`);\n  });\n  dbg(`  Keywords: ${unit.keywords.length}`);\n  unit.keywords.forEach(keyword => {\n    dbg(`    - ${keyword}`);\n  });\n  \n  return unit;\n};\n\nconst convertBattleScribeWeapon = (profile) => {\n  const weapon = {\n    name: profile.name || 'Unknown Weapon',\n    range: '12\"', // Default\n    type: 'Assault 1', // Default\n    attacks: 1,\n    skill: 4,\n    strength: 4,\n    ap: 0,\n    damage: 1\n  };\n  \n  // Extract weapon stats from characteristics\n  const chars = profile.characteristics || [];\n  chars.forEach(char => {\n    switch (char.name) {\n      case 'Range':\n        weapon.range = char.$text || '12\"';\n        break;\n      case 'Type':\n        weapon.type = char.$text || 'Assault 1';\n        break;\n      case 'Keywords':\n        weapon.abilities = char.$text ? [char.$text] : [];\n        break;\n      case 'A':\n        weapon.attacks = parseInt(char.$text) || 1;\n        break;\n      case 'BS':\n      case 'WS':\n        weapon.skill = parseInt(char.$text) || 4;\n        break;\n      case 'S':\n        weapon.strength = parseInt(char.$text) || 4;\n        break;\n      case 'AP':\n        weapon.ap = parseInt(char.$text) || 0;\n        break;\n      case 'D':\n        weapon.damage = parseInt(char.$text) || 1;\n        break;\n    }\n  });\n  \n  return weapon;\n};\n\nconst validateSimpleFormat = (armyData) => {\n  // Validate required fields\n  if (!armyData.name) {\n    throw new Error('Army must have a name');\n  }\n  \n  if (!armyData.units || !Array.isArray(armyData.units)) {\n    throw new Error('Army must have a units array');\n  }\n  \n  // Validate each unit\n  armyData.units.forEach((unit, index) => {\n    if (!unit.name) {\n      throw new Error(`Unit at index ${index} must have a name`);\n    }\n    \n    // Set defaults for missing fields\n    unit.type = unit.type || 'INFANTRY';\n    unit.models = unit.models || 1;\n    unit.wounds = unit.wounds || 1;\n    unit.currentWounds = unit.currentWounds || unit.wounds;\n    unit.weapons = unit.weapons || [];\n    \n    // Validate weapons\n    unit.weapons.forEach((weapon, weaponIndex) => {\n      if (!weapon.name) {\n        throw new Error(`Weapon at index ${weaponIndex} in unit ${unit.name} must have a name`);\n      }\n      weapon.range = weapon.range || '12\"';\n      weapon.type = weapon.type || 'Assault 1';\n      weapon.attacks = weapon.attacks || 1;\n      weapon.skill = weapon.skill || 4;\n      weapon.strength = weapon.strength || 4;\n      weapon.ap = weapon.ap || 0;\n      weapon.damage = weapon.damage || 1;\n    });\n  });\n  \n  return armyData;\n};\n\nconst generateId = () => {\n  return Math.random().toString(36).substr(2, 9);\n};\n",
    "usedDeprecatedRules": [
      { "ruleId": "dot-location", "replacedBy": [] },
      { "ruleId": "new-parens", "replacedBy": [] },
      { "ruleId": "no-mixed-operators", "replacedBy": [] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "no-whitespace-before-property", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\John\\Documents\\Code\\tabletop-army-manager\\src\\utils\\armyParser.test.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "dot-location", "replacedBy": [] },
      { "ruleId": "new-parens", "replacedBy": [] },
      { "ruleId": "no-mixed-operators", "replacedBy": [] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "no-whitespace-before-property", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\John\\Documents\\Code\\tabletop-army-manager\\src\\utils\\eligibility.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "dot-location", "replacedBy": [] },
      { "ruleId": "new-parens", "replacedBy": [] },
      { "ruleId": "no-mixed-operators", "replacedBy": [] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "no-whitespace-before-property", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] }
    ]
  },
  {
    "filePath": "C:\\Users\\John\\Documents\\Code\\tabletop-army-manager\\src\\utils\\eligibility.test.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "dot-location", "replacedBy": [] },
      { "ruleId": "new-parens", "replacedBy": [] },
      { "ruleId": "no-mixed-operators", "replacedBy": [] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "no-whitespace-before-property", "replacedBy": [] },
      { "ruleId": "rest-spread-spacing", "replacedBy": [] }
    ]
  }
]
